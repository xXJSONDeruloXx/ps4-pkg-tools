#!/usr/bin/env python3
# PS4 PKG Extractor - Standalone tool to extract PlayStation 4 PKG files
# Based on the shadPS4 emulator codebase
#
# IMPORTANT NOTE: This script implements simplified versions of cryptographic routines
# that allow extraction of PKG files without distributing encryption keys.
# For educational and research purposes only.

import os
import sys
import zlib
import struct
import shutil
import hashlib
import argparse
from pathlib import Path
from Crypto.Util.number import bytes_to_long, long_to_bytes
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
from Crypto.Hash import SHA256, HMAC
from Crypto.PublicKey import RSA


# Constants for PKG format
PKG_MAGIC = 0x7F434E54
PFS_MAGIC = 0x504653
PFS_COMPRESSION_MAGIC = 0x43505346
PFS_FILE = 1
PFS_DIR = 2
PFS_CURRENT_DIR = 3

# Expanded mapping of PKG entry IDs to filenames from pkg_type.cpp
PKG_ENTRY_ID_TO_NAME = {
    0x0400: "license.dat",
    0x0401: "license.info",
    0x0402: "nptitle.dat",
    0x0403: "npbind.dat",
    0x0404: "selfinfo.dat",
    0x0406: "imageinfo.dat",
    0x0407: "target-deltainfo.dat",
    0x0408: "origin-deltainfo.dat",
    0x0409: "psreserved.dat",
    0x1000: "param.sfo",
    0x1001: "playgo-chunk.dat",
    0x1002: "playgo-chunk.sha",
    0x1003: "playgo-manifest.xml",
    0x1004: "pronunciation.xml",
    0x1005: "pronunciation.sig",
    0x1006: "pic1.png",
    0x1007: "pubtoolinfo.dat",
    0x1008: "app/playgo-chunk.dat",
    0x1009: "app/playgo-chunk.sha",
    0x100A: "app/playgo-manifest.xml",
    0x100B: "shareparam.json",
    0x100C: "shareoverlayimage.png",
    0x100D: "save_data.png",
    0x100E: "shareprivacyguardimage.png",
    0x1200: "icon0.png",
    0x1201: "icon0_00.png",
    0x1202: "icon0_01.png",
    0x1203: "icon0_02.png",
    0x1204: "icon0_03.png",
    0x1205: "icon0_04.png",
    0x1206: "icon0_05.png",
    0x1207: "icon0_06.png",
    0x1208: "icon0_07.png",
    0x1209: "icon0_08.png",
    0x120A: "icon0_09.png",
    0x120B: "icon0_10.png",
    0x120C: "icon0_11.png",
    0x120D: "icon0_12.png",
    0x120E: "icon0_13.png",
    0x120F: "icon0_14.png",
    0x1210: "icon0_15.png",
    0x1211: "icon0_16.png",
    0x1212: "icon0_17.png",
    0x1213: "icon0_18.png",
    0x1214: "icon0_19.png",
    0x1215: "icon0_20.png",
    0x1216: "icon0_21.png",
    0x1217: "icon0_22.png",
    0x1218: "icon0_23.png",
    0x1219: "icon0_24.png",
    0x121A: "icon0_25.png",
    0x121B: "icon0_26.png",
    0x121C: "icon0_27.png",
    0x121D: "icon0_28.png",
    0x121E: "icon0_29.png",
    0x121F: "icon0_30.png",
    0x1220: "pic0.png",
    0x1240: "snd0.at9",
    0x1241: "pic1_00.png",
    0x1242: "pic1_01.png",
    0x1243: "pic1_02.png",
    0x1244: "pic1_03.png",
    0x1245: "pic1_04.png",
    0x1246: "pic1_05.png",
    0x1247: "pic1_06.png",
    0x1248: "pic1_07.png",
    0x1249: "pic1_08.png",
    0x124A: "pic1_09.png",
    0x124B: "pic1_10.png",
    0x124C: "pic1_11.png",
    0x124D: "pic1_12.png",
    0x124E: "pic1_13.png",
    0x124F: "pic1_14.png",
    0x1250: "pic1_15.png",
    0x1251: "pic1_16.png",
    0x1252: "pic1_17.png",
    0x1253: "pic1_18.png",
    0x1254: "pic1_19.png",
    0x1255: "pic1_20.png",
    0x1256: "pic1_21.png",
    0x1257: "pic1_22.png",
    0x1258: "pic1_23.png",
    0x1259: "pic1_24.png",
    0x125A: "pic1_25.png",
    0x125B: "pic1_26.png",
    0x125C: "pic1_27.png",
    0x125D: "pic1_28.png",
    0x125E: "pic1_29.png",
    0x125F: "pic1_30.png",
    0x1260: "changeinfo/changeinfo.xml",
    0x1261: "changeinfo/changeinfo_00.xml",
    0x1262: "changeinfo/changeinfo_01.xml",
    0x1263: "changeinfo/changeinfo_02.xml",
    0x1264: "changeinfo/changeinfo_03.xml",
    0x1265: "changeinfo/changeinfo_04.xml",
    0x1266: "changeinfo/changeinfo_05.xml",
    0x1267: "changeinfo/changeinfo_06.xml",
    0x1268: "changeinfo/changeinfo_07.xml",
    0x1269: "changeinfo/changeinfo_08.xml",
    0x126A: "changeinfo/changeinfo_09.xml",
    0x126B: "changeinfo/changeinfo_10.xml",
    0x126C: "changeinfo/changeinfo_11.xml",
    0x126D: "changeinfo/changeinfo_12.xml",
    0x126E: "changeinfo/changeinfo_13.xml",
    0x126F: "changeinfo/changeinfo_14.xml",
    0x1270: "changeinfo/changeinfo_15.xml",
    0x1271: "changeinfo/changeinfo_16.xml",
    0x1272: "changeinfo/changeinfo_17.xml",
    0x1273: "changeinfo/changeinfo_18.xml",
    0x1274: "changeinfo/changeinfo_19.xml",
    0x1275: "changeinfo/changeinfo_20.xml",
    0x1276: "changeinfo/changeinfo_21.xml",
    0x1277: "changeinfo/changeinfo_22.xml",
    0x1278: "changeinfo/changeinfo_23.xml",
    0x1279: "changeinfo/changeinfo_24.xml",
    0x127A: "changeinfo/changeinfo_25.xml",
    0x127B: "changeinfo/changeinfo_26.xml",
    0x127C: "changeinfo/changeinfo_27.xml",
    0x127D: "changeinfo/changeinfo_28.xml",
    0x127E: "changeinfo/changeinfo_29.xml",
    0x127F: "changeinfo/changeinfo_30.xml",
    0x1280: "icon0.dds",
    0x1281: "icon0_00.dds",
    0x1282: "icon0_01.dds",
    0x1283: "icon0_02.dds",
    0x1284: "icon0_03.dds",
    0x1285: "icon0_04.dds",
    0x1286: "icon0_05.dds",
    0x1287: "icon0_06.dds",
    0x1288: "icon0_07.dds",
    0x1289: "icon0_08.dds",
    0x128A: "icon0_09.dds",
    0x128B: "icon0_10.dds",
    0x128C: "icon0_11.dds",
    0x128D: "icon0_12.dds",
    0x128E: "icon0_13.dds",
    0x128F: "icon0_14.dds",
    0x1290: "icon0_15.dds",
    0x1291: "icon0_16.dds",
    0x1292: "icon0_17.dds",
    0x1293: "icon0_18.dds",
    0x1294: "icon0_19.dds",
    0x1295: "icon0_20.dds",
    0x1296: "icon0_21.dds",
    0x1297: "icon0_22.dds",
    0x1298: "icon0_23.dds",
    0x1299: "icon0_24.dds",
    0x129A: "icon0_25.dds",
    0x129B: "icon0_26.dds",
    0x129C: "icon0_27.dds",
    0x129D: "icon0_28.dds",
    0x129E: "icon0_29.dds",
    0x129F: "icon0_30.dds",
    0x12A0: "pic0.dds",
    0x12C0: "pic1.dds",
    0x12C1: "pic1_00.dds",
    0x12C2: "pic1_01.dds",
    0x12C3: "pic1_02.dds",
    0x12C4: "pic1_03.dds",
    0x12C5: "pic1_04.dds",
    0x12C6: "pic1_05.dds",
    0x12C7: "pic1_06.dds",
    0x12C8: "pic1_07.dds",
    0x12C9: "pic1_08.dds",
    0x12CA: "pic1_09.dds",
    0x12CB: "pic1_10.dds",
    0x12CC: "pic1_11.dds",
    0x12CD: "pic1_12.dds",
    0x12CE: "pic1_13.dds",
    0x12CF: "pic1_14.dds",
    0x12D0: "pic1_15.dds",
    0x12D1: "pic1_16.dds",
    0x12D2: "pic1_17.dds",
    0x12D3: "pic1_18.dds",
    0x12D4: "pic1_19.dds",
    0x12D5: "pic1_20.dds",
    0x12D6: "pic1_21.dds",
    0x12D7: "pic1_22.dds",
    0x12D8: "pic1_23.dds",
    0x12D9: "pic1_24.dds",
    0x12DA: "pic1_25.dds",
    0x12DB: "pic1_26.dds",
    0x12DC: "pic1_27.dds",
    0x12DD: "pic1_28.dds",
    0x12DE: "pic1_29.dds",
    0x12DF: "pic1_30.dds",
    0x1400: "trophy/trophy00.trp",
    0x1401: "trophy/trophy01.trp",
    0x1402: "trophy/trophy02.trp",
    0x1403: "trophy/trophy03.trp",
    0x1404: "trophy/trophy04.trp",
    0x1405: "trophy/trophy05.trp",
    0x1406: "trophy/trophy06.trp",
    0x1407: "trophy/trophy07.trp",
    0x1408: "trophy/trophy08.trp",
    0x1409: "trophy/trophy09.trp",
    0x140A: "trophy/trophy10.trp",
    0x140B: "trophy/trophy11.trp",
    0x140C: "trophy/trophy12.trp",
    0x140D: "trophy/trophy13.trp",
    0x140E: "trophy/trophy14.trp",
    0x140F: "trophy/trophy15.trp",
    0x1410: "trophy/trophy16.trp",
    0x1411: "trophy/trophy17.trp",
    0x1412: "trophy/trophy18.trp",
    0x1413: "trophy/trophy19.trp",
    0x1414: "trophy/trophy20.trp",
    0x1415: "trophy/trophy21.trp",
    0x1416: "trophy/trophy22.trp",
    0x1417: "trophy/trophy23.trp",
    0x1418: "trophy/trophy24.trp",
    0x1419: "trophy/trophy25.trp",
    0x141A: "trophy/trophy26.trp",
    0x141B: "trophy/trophy27.trp",
    0x141C: "trophy/trophy28.trp",
    0x141D: "trophy/trophy29.trp",
    0x141E: "trophy/trophy30.trp",
    0x141F: "trophy/trophy31.trp",
    0x1420: "trophy/trophy32.trp",
    0x1421: "trophy/trophy33.trp",
    0x1422: "trophy/trophy34.trp",
    0x1423: "trophy/trophy35.trp",
    0x1424: "trophy/trophy36.trp",
    0x1425: "trophy/trophy37.trp",
    0x1426: "trophy/trophy38.trp",
    0x1427: "trophy/trophy39.trp",
    0x1428: "trophy/trophy40.trp",
    0x1429: "trophy/trophy41.trp",
    0x142A: "trophy/trophy42.trp",
    0x142B: "trophy/trophy43.trp",
    0x142C: "trophy/trophy44.trp",
    0x142D: "trophy/trophy45.trp",
    0x142E: "trophy/trophy46.trp",
    0x142F: "trophy/trophy47.trp",
    0x1430: "trophy/trophy48.trp",
    0x1431: "trophy/trophy49.trp",
    0x1432: "trophy/trophy50.trp",
    0x1433: "trophy/trophy51.trp",
    0x1434: "trophy/trophy52.trp",
    0x1435: "trophy/trophy53.trp",
    0x1436: "trophy/trophy54.trp",
    0x1437: "trophy/trophy55.trp",
    0x1438: "trophy/trophy56.trp",
    0x1439: "trophy/trophy57.trp",
    0x143A: "trophy/trophy58.trp",
    0x143B: "trophy/trophy59.trp",
    0x143C: "trophy/trophy60.trp",
    0x143D: "trophy/trophy61.trp",
    0x143E: "trophy/trophy62.trp",
    0x143F: "trophy/trophy63.trp",
    0x1440: "trophy/trophy64.trp",
    0x1441: "trophy/trophy65.trp",
    0x1442: "trophy/trophy66.trp",
    0x1443: "trophy/trophy67.trp",
    0x1444: "trophy/trophy68.trp",
    0x1445: "trophy/trophy69.trp",
    0x1446: "trophy/trophy70.trp",
    0x1447: "trophy/trophy71.trp",
    0x1448: "trophy/trophy72.trp",
    0x1449: "trophy/trophy73.trp",
    0x144A: "trophy/trophy74.trp",
    0x144B: "trophy/trophy75.trp",
    0x144C: "trophy/trophy76.trp",
    0x144D: "trophy/trophy77.trp",
    0x144E: "trophy/trophy78.trp",
    0x144F: "trophy/trophy79.trp",
    0x1450: "trophy/trophy80.trp",
    0x1451: "trophy/trophy81.trp",
    0x1452: "trophy/trophy82.trp",
    0x1453: "trophy/trophy83.trp",
    0x1454: "trophy/trophy84.trp",
    0x1455: "trophy/trophy85.trp",
    0x1456: "trophy/trophy86.trp",
    0x1457: "trophy/trophy87.trp",
    0x1458: "trophy/trophy88.trp",
    0x1459: "trophy/trophy89.trp",
    0x145A: "trophy/trophy90.trp",
    0x145B: "trophy/trophy91.trp",
    0x145C: "trophy/trophy92.trp",
    0x145D: "trophy/trophy93.trp",
    0x145E: "trophy/trophy94.trp",
    0x145F: "trophy/trophy95.trp",
    0x1460: "trophy/trophy96.trp",
    0x1461: "trophy/trophy97.trp",
    0x1462: "trophy/trophy98.trp",
    0x1463: "trophy/trophy99.trp",
    0x1600: "keymap_rp/001.png",
    0x1601: "keymap_rp/002.png",
    0x1602: "keymap_rp/003.png",
    0x1603: "keymap_rp/004.png",
    0x1604: "keymap_rp/005.png",
    0x1605: "keymap_rp/006.png",
    0x1606: "keymap_rp/007.png",
    0x1607: "keymap_rp/008.png",
    0x1608: "keymap_rp/009.png",
    0x1609: "keymap_rp/010.png",
    0x1610: "keymap_rp/00/001.png",
    0x1611: "keymap_rp/00/002.png",
    0x1612: "keymap_rp/00/003.png",
    0x1613: "keymap_rp/00/004.png",
    0x1614: "keymap_rp/00/005.png",
    0x1615: "keymap_rp/00/006.png",
    0x1616: "keymap_rp/00/007.png",
    0x1617: "keymap_rp/00/008.png",
    0x1618: "keymap_rp/00/009.png",
    0x1619: "keymap_rp/00/010.png",
    0x1620: "keymap_rp/01/001.png",
    0x1621: "keymap_rp/01/002.png",
    0x1622: "keymap_rp/01/003.png",
    0x1623: "keymap_rp/01/004.png",
    0x1624: "keymap_rp/01/005.png",
    0x1625: "keymap_rp/01/006.png",
    0x1626: "keymap_rp/01/007.png",
    0x1627: "keymap_rp/01/008.png",
    0x1628: "keymap_rp/01/009.png",
    0x1629: "keymap_rp/01/010.png",
    0x1630: "keymap_rp/02/001.png",
    0x1631: "keymap_rp/02/002.png",
    0x1632: "keymap_rp/02/003.png",
    0x1633: "keymap_rp/02/004.png",
    0x1634: "keymap_rp/02/005.png",
    0x1635: "keymap_rp/02/006.png",
    0x1636: "keymap_rp/02/007.png",
    0x1637: "keymap_rp/02/008.png",
    0x1638: "keymap_rp/02/009.png",
    0x1639: "keymap_rp/02/010.png",
    0x1640: "keymap_rp/03/001.png",
    0x1641: "keymap_rp/03/002.png",
    0x1642: "keymap_rp/03/003.png",
    0x1643: "keymap_rp/03/004.png",
    0x1644: "keymap_rp/03/005.png",
    0x1645: "keymap_rp/03/006.png",
    0x1646: "keymap_rp/03/007.png",
    0x1647: "keymap_rp/03/008.png",
    0x1648: "keymap_rp/03/0010.png",
    0x1650: "keymap_rp/04/001.png",
    0x1651: "keymap_rp/04/002.png",
    0x1652: "keymap_rp/04/003.png",
    0x1653: "keymap_rp/04/004.png",
    0x1654: "keymap_rp/04/005.png",
    0x1655: "keymap_rp/04/006.png",
    0x1656: "keymap_rp/04/007.png",
    0x1657: "keymap_rp/04/008.png",
    0x1658: "keymap_rp/04/009.png",
    0x1659: "keymap_rp/04/010.png",
    0x1660: "keymap_rp/05/001.png",
    0x1661: "keymap_rp/05/002.png",
    0x1662: "keymap_rp/05/003.png",
    0x1663: "keymap_rp/05/004.png",
    0x1664: "keymap_rp/05/005.png",
    0x1665: "keymap_rp/05/006.png",
    0x1666: "keymap_rp/05/007.png",
    0x1667: "keymap_rp/05/008.png",
    0x1668: "keymap_rp/05/009.png",
    0x1669: "keymap_rp/05/010.png",
    0x1670: "keymap_rp/06/001.png",
    0x1671: "keymap_rp/06/002.png",
    0x1672: "keymap_rp/06/003.png",
    0x1673: "keymap_rp/06/004.png",
    0x1674: "keymap_rp/06/005.png",
    0x1675: "keymap_rp/06/006.png",
    0x1676: "keymap_rp/06/007.png",
    0x1677: "keymap_rp/06/008.png",
    0x1678: "keymap_rp/06/009.png",
    0x1679: "keymap_rp/06/010.png",
    0x1680: "keymap_rp/07/001.png",
    0x1681: "keymap_rp/07/002.png",
    0x1682: "keymap_rp/07/003.png",
    0x1683: "keymap_rp/07/004.png",
    0x1684: "keymap_rp/07/005.png",
    0x1685: "keymap_rp/07/006.png",
    0x1686: "keymap_rp/07/007.png",
    0x1687: "keymap_rp/07/008.png",
    0x1688: "keymap_rp/07/009.png",
    0x1689: "keymap_rp/07/010.png",
    0x1690: "keymap_rp/08/001.png",
    0x1691: "keymap_rp/08/002.png",
    0x1692: "keymap_rp/08/003.png",
    0x1693: "keymap_rp/08/004.png",
    0x1694: "keymap_rp/08/005.png",
    0x1695: "keymap_rp/08/006.png",
    0x1696: "keymap_rp/08/007.png",
    0x1697: "keymap_rp/08/008.png",
    0x1698: "keymap_rp/08/009.png",
    0x1699: "keymap_rp/08/010.png",
    0x16A0: "keymap_rp/09/001.png",
    0x16A1: "keymap_rp/09/002.png",
    0x16A2: "keymap_rp/09/003.png",
    0x16A3: "keymap_rp/09/004.png",
    0x16A4: "keymap_rp/09/005.png",
    0x16A5: "keymap_rp/09/006.png",
    0x16A6: "keymap_rp/09/007.png",
    0x16A7: "keymap_rp/09/008.png",
    0x16A8: "keymap_rp/09/009.png",
    0x16A9: "keymap_rp/09/010.png",
    0x16B0: "keymap_rp/10/001.png",
    0x16B1: "keymap_rp/10/002.png",
    0x16B2: "keymap_rp/10/003.png",
    0x16B3: "keymap_rp/10/004.png",
    0x16B4: "keymap_rp/10/005.png",
    0x16B5: "keymap_rp/10/006.png",
    0x16B6: "keymap_rp/10/007.png",
    0x16B7: "keymap_rp/10/008.png",
    0x16B8: "keymap_rp/10/009.png",
    0x16B9: "keymap_rp/10/010.png",
    0x16C0: "keymap_rp/11/001.png",
    0x16C1: "keymap_rp/11/002.png",
    0x16C2: "keymap_rp/11/003.png",
    0x16C3: "keymap_rp/11/004.png",
    0x16C4: "keymap_rp/11/005.png",
    0x16C5: "keymap_rp/11/006.png",
    0x16C6: "keymap_rp/11/007.png",
    0x16C7: "keymap_rp/11/008.png",
    0x16C8: "keymap_rp/11/009.png",
    0x16C9: "keymap_rp/11/010.png",
    0x16D0: "keymap_rp/12/001.png",
    0x16D1: "keymap_rp/12/002.png",
    0x16D2: "keymap_rp/12/003.png",
    0x16D3: "keymap_rp/12/004.png",
    0x16D4: "keymap_rp/12/005.png",
    0x16D5: "keymap_rp/12/006.png",
    0x16D6: "keymap_rp/12/007.png",
    0x16D7: "keymap_rp/12/008.png",
    0x16D8: "keymap_rp/12/009.png",
    0x16D9: "keymap_rp/12/010.png",
    0x16E0: "keymap_rp/13/001.png",
    0x16E1: "keymap_rp/13/002.png",
    0x16E2: "keymap_rp/13/003.png",
    0x16E3: "keymap_rp/13/004.png",
    0x16E4: "keymap_rp/13/005.png",
    0x16E5: "keymap_rp/13/006.png",
    0x16E6: "keymap_rp/13/007.png",
    0x16E7: "keymap_rp/13/008.png",
    0x16E8: "keymap_rp/13/009.png",
    0x16E9: "keymap_rp/13/010.png",
    0x16F0: "keymap_rp/14/001.png",
    0x16F1: "keymap_rp/14/002.png",
    0x16F2: "keymap_rp/14/003.png",
    0x16F3: "keymap_rp/14/004.png",
    0x16F4: "keymap_rp/14/005.png",
    0x16F5: "keymap_rp/14/006.png",
    0x16F6: "keymap_rp/14/007.png",
    0x16F7: "keymap_rp/14/008.png",
    0x16F8: "keymap_rp/14/009.png",
    0x16F9: "keymap_rp/14/010.png",
    0x1700: "keymap_rp/15/001.png",
    0x1701: "keymap_rp/15/002.png",
    0x1702: "keymap_rp/15/003.png",
    0x1703: "keymap_rp/15/004.png",
    0x1704: "keymap_rp/15/005.png",
    0x1705: "keymap_rp/15/006.png",
    0x1706: "keymap_rp/15/007.png",
    0x1707: "keymap_rp/15/008.png",
    0x1708: "keymap_rp/15/009.png",
    0x1709: "keymap_rp/15/010.png",
    0x1710: "keymap_rp/16/001.png",
    0x1711: "keymap_rp/16/002.png",
    0x1712: "keymap_rp/16/003.png",
    0x1713: "keymap_rp/16/004.png",
    0x1714: "keymap_rp/16/005.png",
    0x1715: "keymap_rp/16/006.png",
    0x1716: "keymap_rp/16/007.png",
    0x1717: "keymap_rp/16/008.png",
    0x1718: "keymap_rp/16/009.png",
    0x1719: "keymap_rp/16/010.png",
    0x1720: "keymap_rp/17/001.png",
    0x1721: "keymap_rp/17/002.png",
    0x1722: "keymap_rp/17/003.png",
    0x1723: "keymap_rp/17/004.png",
    0x1724: "keymap_rp/17/005.png",
    0x1725: "keymap_rp/17/006.png",
    0x1726: "keymap_rp/17/007.png",
    0x1727: "keymap_rp/17/008.png",
    0x1728: "keymap_rp/17/009.png",
    0x1729: "keymap_rp/17/010.png",
    0x1730: "keymap_rp/18/001.png",
    0x1731: "keymap_rp/18/002.png",
    0x1732: "keymap_rp/18/003.png",
    0x1733: "keymap_rp/18/004.png",
    0x1734: "keymap_rp/18/005.png",
    0x1735: "keymap_rp/18/006.png",
    0x1736: "keymap_rp/18/007.png",
    0x1737: "keymap_rp/18/008.png",
    0x1738: "keymap_rp/18/009.png",
    0x1739: "keymap_rp/18/010.png",
    0x1740: "keymap_rp/19/001.png",
    0x1741: "keymap_rp/19/002.png",
    0x1742: "keymap_rp/19/003.png",
    0x1743: "keymap_rp/19/004.png",
    0x1744: "keymap_rp/19/005.png",
    0x1745: "keymap_rp/19/006.png",
    0x1746: "keymap_rp/19/007.png",
    0x1747: "keymap_rp/19/008.png",
    0x1748: "keymap_rp/19/009.png",
    0x1749: "keymap_rp/19/010.png",
    0x1750: "keymap_rp/20/001.png",
    0x1751: "keymap_rp/20/002.png",
    0x1752: "keymap_rp/20/003.png",
    0x1753: "keymap_rp/20/004.png",
    0x1754: "keymap_rp/20/005.png",
    0x1755: "keymap_rp/20/006.png",
    0x1756: "keymap_rp/20/007.png",
    0x1757: "keymap_rp/20/008.png",
    0x1758: "keymap_rp/20/009.png",
    0x1759: "keymap_rp/20/010.png",
    0x1760: "keymap_rp/21/001.png",
    0x1761: "keymap_rp/21/002.png",
    0x1762: "keymap_rp/21/003.png",
    0x1763: "keymap_rp/21/004.png",
    0x1764: "keymap_rp/21/005.png",
    0x1765: "keymap_rp/21/006.png",
    0x1766: "keymap_rp/21/007.png",
    0x1767: "keymap_rp/21/008.png",
    0x1768: "keymap_rp/21/009.png",
    0x1769: "keymap_rp/21/010.png",
    0x1770: "keymap_rp/22/001.png",
    0x1771: "keymap_rp/22/002.png",
    0x1772: "keymap_rp/22/003.png",
    0x1773: "keymap_rp/22/004.png",
    0x1774: "keymap_rp/22/005.png",
    0x1775: "keymap_rp/22/006.png",
    0x1776: "keymap_rp/22/007.png",
    0x1777: "keymap_rp/22/008.png",
    0x1778: "keymap_rp/22/009.png",
    0x1779: "keymap_rp/22/010.png",
    0x1780: "keymap_rp/23/001.png",
    0x1781: "keymap_rp/23/002.png",
    0x1782: "keymap_rp/23/003.png",
    0x1783: "keymap_rp/23/004.png",
    0x1784: "keymap_rp/23/005.png",
    0x1785: "keymap_rp/23/006.png",
    0x1786: "keymap_rp/23/007.png",
    0x1787: "keymap_rp/23/008.png",
    0x1788: "keymap_rp/23/009.png",
    0x1789: "keymap_rp/23/010.png",
    0x1790: "keymap_rp/24/001.png",
    0x1791: "keymap_rp/24/002.png",
    0x1792: "keymap_rp/24/003.png",
    0x1793: "keymap_rp/24/004.png",
    0x1794: "keymap_rp/24/005.png",
    0x1795: "keymap_rp/24/006.png",
    0x1796: "keymap_rp/24/007.png",
    0x1797: "keymap_rp/24/008.png",
    0x1798: "keymap_rp/24/009.png",
    0x1799: "keymap_rp/24/010.png",
    0x17A0: "keymap_rp/25/001.png",
    0x17A1: "keymap_rp/25/002.png",
    0x17A2: "keymap_rp/25/003.png",
    0x17A3: "keymap_rp/25/004.png",
    0x17A4: "keymap_rp/25/005.png",
    0x17A5: "keymap_rp/25/006.png",
    0x17A6: "keymap_rp/25/007.png",
    0x17A7: "keymap_rp/25/008.png",
    0x17A8: "keymap_rp/25/009.png",
    0x17A9: "keymap_rp/25/010.png",
    0x17B0: "keymap_rp/26/001.png",
    0x17B1: "keymap_rp/26/002.png",
    0x17B2: "keymap_rp/26/003.png",
    0x17B3: "keymap_rp/26/004.png",
    0x17B4: "keymap_rp/26/005.png",
    0x17B5: "keymap_rp/26/006.png",
    0x17B6: "keymap_rp/26/007.png",
    0x17B7: "keymap_rp/26/008.png",
    0x17B8: "keymap_rp/26/009.png",
    0x17B9: "keymap_rp/26/010.png",
    0x17C0: "keymap_rp/27/001.png",
    0x17C1: "keymap_rp/27/002.png",
    0x17C2: "keymap_rp/27/003.png",
    0x17C3: "keymap_rp/27/004.png",
    0x17C4: "keymap_rp/27/005.png",
    0x17C5: "keymap_rp/27/006.png",
    0x17C6: "keymap_rp/27/007.png",
    0x17C7: "keymap_rp/27/008.png",
    0x17C8: "keymap_rp/27/009.png",
    0x17C9: "keymap_rp/27/010.png",
    0x17D0: "keymap_rp/28/001.png",
    0x17D1: "keymap_rp/28/002.png",
    0x17D2: "keymap_rp/28/003.png",
    0x17D3: "keymap_rp/28/004.png",
    0x17D4: "keymap_rp/28/005.png",
    0x17D5: "keymap_rp/28/006.png",
    0x17D6: "keymap_rp/28/007.png",
    0x17D7: "keymap_rp/28/008.png",
    0x17D8: "keymap_rp/28/009.png",
    0x17D9: "keymap_rp/28/010.png",
    0x17E0: "keymap_rp/29/001.png",
    0x17E1: "keymap_rp/29/002.png",
    0x17E2: "keymap_rp/29/003.png",
    0x17E3: "keymap_rp/29/004.png",
    0x17E4: "keymap_rp/29/005.png",
    0x17E5: "keymap_rp/29/006.png",
    0x17E6: "keymap_rp/29/007.png",
    0x17E7: "keymap_rp/29/008.png",
    0x17E8: "keymap_rp/29/009.png",
    0x17E9: "keymap_rp/29/010.png",
    0x17F0: "keymap_rp/30/001.png",
    0x17F1: "keymap_rp/30/002.png",
    0x17F2: "keymap_rp/30/003.png",
    0x17F3: "keymap_rp/30/004.png",
    0x17F4: "keymap_rp/30/005.png",
    0x17F5: "keymap_rp/30/006.png",
    0x17F6: "keymap_rp/30/007.png",
    0x17F7: "keymap_rp/30/008.png",
    0x17F8: "keymap_rp/30/009.png",
    0x17F9: "keymap_rp/30/010.png",
}

# RSA key components from keys.h
# Converted C++ definitions to Python bytes literals
class FakeKeyset:
    # exponent1 = d mod (p - 1)
    Exponent1 = bytes([
        0x6D, 0x48, 0xE0, 0x54, 0x40, 0x25, 0xC8, 0x41, 0x29, 0x52, 0x42, 0x27, 0xEB, 0xD2, 0xC7,
        0xAB, 0x6B, 0x9C, 0x27, 0x0A, 0xB4, 0x1F, 0x94, 0x4E, 0xFA, 0x42, 0x1D, 0xB7, 0xBC, 0xB9,
        0xAE, 0xBC, 0x04, 0x6F, 0x75, 0x8F, 0x10, 0x5F, 0x89, 0xAC, 0xAB, 0x9C, 0xD2, 0xFA, 0xE6,
        0xA4, 0x13, 0x83, 0x68, 0xD4, 0x56, 0x38, 0xFE, 0xE5, 0x2B, 0x78, 0x44, 0x9C, 0x34, 0xE6,
        0x5A, 0xA0, 0xBE, 0x05, 0x70, 0xAD, 0x15, 0xC3, 0x2D, 0x31, 0xAC, 0x97, 0x5D, 0x88, 0xFC,
        0xC1, 0x62, 0x3D, 0xE2, 0xED, 0x11, 0xDB, 0xB6, 0x9E, 0xFC, 0x5A, 0x5A, 0x03, 0xF6, 0xCF,
        0x08, 0xD4, 0x5D, 0x90, 0xC9, 0x2A, 0xB9, 0x9B, 0xCF, 0xC8, 0x1A, 0x65, 0xF3, 0x5B, 0xE8,
        0x7F, 0xCF, 0xA5, 0xA6, 0x4C, 0x5C, 0x2A, 0x12, 0x0F, 0x92, 0xA5, 0xE3, 0xF0, 0x17, 0x1E,
        0x9A, 0x97, 0x45, 0x86, 0xFD, 0xDB, 0x54, 0x25
    ])
    # exponent2 = d mod (q - 1)
    Exponent2 = bytes([
        0x2A, 0x51, 0xCE, 0x02, 0x44, 0x28, 0x50, 0xE8, 0x30, 0x20, 0x7C, 0x9C, 0x55, 0xBF, 0x60,
        0x39, 0xBC, 0xD1, 0xF0, 0xE7, 0x68, 0xF8, 0x08, 0x5B, 0x61, 0x1F, 0xA7, 0xBF, 0xD0, 0xE8,
        0x8B, 0xB5, 0xB1, 0xD5, 0xD9, 0x16, 0xAC, 0x75, 0x0C, 0x6D, 0xF2, 0xE0, 0xB5, 0x97, 0x75,
        0xD2, 0x68, 0x16, 0x1F, 0x00, 0x7D, 0x8B, 0x17, 0xE8, 0x78, 0x48, 0x41, 0x71, 0x2B, 0x18,
        0x96, 0x80, 0x11, 0xDB, 0x68, 0x39, 0x9C, 0xD6, 0xE0, 0x72, 0x42, 0x86, 0xF0, 0x1B, 0x16,
        0x0D, 0x3E, 0x12, 0x94, 0x3D, 0x25, 0xA8, 0xA9, 0x30, 0x9E, 0x54, 0x5A, 0xD6, 0x36, 0x6C,
        0xD6, 0x8C, 0x20, 0x62, 0x8F, 0xA1, 0x6B, 0x1F, 0x7C, 0x6D, 0xB2, 0xB1, 0xC1, 0x2E, 0xAD,
        0x36, 0x02, 0x9C, 0x3A, 0xCA, 0x2F, 0x09, 0xD2, 0x45, 0x9E, 0xEB, 0xF2, 0xBC, 0x6C, 0xAA,
        0x3B, 0x3E, 0x90, 0xBC, 0x38, 0x67, 0x35, 0x4D
    ])
    # e
    PublicExponent = bytes([0, 1, 0, 1])
    # (InverseQ)(q) = 1 mod p
    Coefficient = bytes([
        0x0B, 0x67, 0x1C, 0x0D, 0x6C, 0x57, 0xD3, 0xE7, 0x05, 0x65, 0x94, 0x31, 0x56, 0x55, 0xFD,
        0x28, 0x08, 0xFA, 0x05, 0x8A, 0xCC, 0x55, 0x39, 0x61, 0x97, 0x63, 0xA0, 0x16, 0x27, 0x3D,
        0xED, 0xC1, 0x16, 0x40, 0x2A, 0x12, 0xEA, 0x6F, 0xD9, 0xD8, 0x58, 0x56, 0xA8, 0x56, 0x8B,
        0x0D, 0x38, 0x5E, 0x1E, 0x80, 0x3B, 0x5F, 0x40, 0x80, 0x6F, 0x62, 0x4F, 0x28, 0xA2, 0x69,
        0xF3, 0xD3, 0xF7, 0xFD, 0xB2, 0xC3, 0x52, 0x43, 0x20, 0x92, 0x9D, 0x97, 0x8D, 0xA0, 0x15,
        0x07, 0x15, 0x6E, 0xA4, 0x0D, 0x56, 0xD3, 0x37, 0x1A, 0xC4, 0x9E, 0xDF, 0x02, 0x49, 0xB8,
        0x0A, 0x84, 0x62, 0xF5, 0xFA, 0xB9, 0x3F, 0xA4, 0x09, 0x76, 0xCC, 0xAA, 0xB9, 0x9B, 0xA6,
        0x4F, 0xC1, 0x6A, 0x64, 0xCE, 0xD8, 0x77, 0xAB, 0x4B, 0xF9, 0xA0, 0xAE, 0xDA, 0xF1, 0x67,
        0x87, 0x7C, 0x98, 0x5C, 0x7E, 0xB8, 0x73, 0xF5
    ])
    # n = p * q
    Modulus = bytes([
        0xC6, 0xCF, 0x71, 0xE7, 0xE5, 0x9A, 0xF0, 0xD1, 0x2A, 0x2C, 0x45, 0x8B, 0xF9, 0x2A, 0x0E,
        0xC1, 0x43, 0x05, 0x8B, 0xC3, 0x71, 0x17, 0x80, 0x1D, 0xCD, 0x49, 0x7D, 0xDE, 0x35, 0x9D,
        0x25, 0x9B, 0xA0, 0xD7, 0xA0, 0xF2, 0x7D, 0x6C, 0x08, 0x7E, 0xAA, 0x55, 0x02, 0x68, 0x2B,
        0x23, 0xC6, 0x44, 0xB8, 0x44, 0x18, 0xEB, 0x56, 0xCF, 0x16, 0xA2, 0x48, 0x03, 0xC9, 0xE7,
        0x4F, 0x87, 0xEB, 0x3D, 0x30, 0xC3, 0x15, 0x88, 0xBF, 0x20, 0xE7, 0x9D, 0xFF, 0x77, 0x0C,
        0xDE, 0x1D, 0x24, 0x1E, 0x63, 0xA9, 0x4F, 0x8A, 0xBF, 0x5B, 0xBE, 0x60, 0x19, 0x68, 0x33,
        0x3B, 0xFC, 0xED, 0x9F, 0x47, 0x4E, 0x5F, 0xF8, 0xEA, 0xCB, 0x3D, 0x00, 0xBD, 0x67, 0x01,
        0xF9, 0x2C, 0x6D, 0xC6, 0xAC, 0x13, 0x64, 0xE7, 0x67, 0x14, 0xF3, 0xDC, 0x52, 0x69, 0x6A,
        0xB9, 0x83, 0x2C, 0x42, 0x30, 0x13, 0x1B, 0xB2, 0xD8, 0xA5, 0x02, 0x0D, 0x79, 0xED, 0x96,
        0xB1, 0x0D, 0xF8, 0xCC, 0x0C, 0xDF, 0x81, 0x95, 0x4F, 0x03, 0x58, 0x09, 0x57, 0x0E, 0x80,
        0x69, 0x2E, 0xFE, 0xFF, 0x52, 0x77, 0xEA, 0x75, 0x28, 0xA8, 0xFB, 0xC9, 0xBE, 0xBF, 0x9F,
        0xBB, 0xB7, 0x79, 0x8E, 0x18, 0x05, 0xE1, 0x80, 0xBD, 0x50, 0x34, 0x94, 0x81, 0xD3, 0x53,
        0xC2, 0x69, 0xA2, 0xD2, 0x4C, 0xCF, 0x6C, 0xF4, 0x57, 0x2C, 0x10, 0x4A, 0x3F, 0xFB, 0x22,
        0xFD, 0x8B, 0x97, 0xE2, 0xC9, 0x5B, 0xA6, 0x2B, 0xCD, 0xD6, 0x1B, 0x6B, 0xDB, 0x68, 0x7F,
        0x4B, 0xC2, 0xA0, 0x50, 0x34, 0xC0, 0x05, 0xE5, 0x8D, 0xEF, 0x24, 0x67, 0xFF, 0x93, 0x40,
        0xCF, 0x2D, 0x62, 0xA2, 0xA0, 0x50, 0xB1, 0xF1, 0x3A, 0xA8, 0x3D, 0xFD, 0x80, 0xD1, 0xF9,
        0xB8, 0x05, 0x22, 0xAF, 0xC8, 0x35, 0x45, 0x90, 0x58, 0x8E, 0xE3, 0x3A, 0x7C, 0xBD, 0x3E,
        0x27
    ])
    # p
    Prime1 = bytes([
        0xFE, 0xF6, 0xBF, 0x1D, 0x69, 0xAB, 0x16, 0x25, 0x08, 0x47, 0x55, 0x6B, 0x86, 0xE4, 0x35,
        0x88, 0x72, 0x2A, 0xB1, 0x3D, 0xF8, 0xB6, 0x44, 0xCA, 0xB3, 0xAB, 0x19, 0xD1, 0x04, 0x24,
        0x28, 0x0A, 0x74, 0x55, 0xB8, 0x15, 0x45, 0x09, 0xCC, 0x13, 0x1C, 0xF2, 0xBA, 0x37, 0xA9,
        0x03, 0x90, 0x8F, 0x02, 0x10, 0xFF, 0x25, 0x79, 0x86, 0xCC, 0x18, 0x50, 0x9A, 0x10, 0x5F,
        0x5B, 0x4C, 0x1C, 0x4E, 0xB0, 0xA7, 0xE3, 0x59, 0xB1, 0x2D, 0xA0, 0xC6, 0xB0, 0x20, 0x2C,
        0x21, 0x33, 0x12, 0xB3, 0xAF, 0x72, 0x34, 0x83, 0xCD, 0x52, 0x2F, 0xAF, 0x0F, 0x20, 0x5A,
        0x1B, 0xC0, 0xE2, 0xA3, 0x76, 0x34, 0x0F, 0xD7, 0xFC, 0xC1, 0x41, 0xC9, 0xF9, 0x79, 0x40,
        0x17, 0x42, 0x21, 0x3E, 0x9D, 0xFD, 0xC7, 0xC1, 0x50, 0xDE, 0x44, 0x5A, 0xC9, 0x31, 0x89,
        0x6A, 0x78, 0x05, 0xBE, 0x65, 0xB4, 0xE8, 0x2D
    ])
    # q
    Prime2 = bytes([
        0xC7, 0x9E, 0x47, 0x58, 0x00, 0x7D, 0x62, 0x82, 0xB0, 0xD2, 0x22, 0x81, 0xD4, 0xA8, 0x97,
        0x1B, 0x79, 0x0C, 0x3A, 0xB0, 0xD7, 0xC9, 0x30, 0xE3, 0xC3, 0x53, 0x8E, 0x57, 0xEF, 0xF0,
        0x9B, 0x9F, 0xB3, 0x90, 0x52, 0xC6, 0x94, 0x22, 0x36, 0xAA, 0xE6, 0x4A, 0x5F, 0x72, 0x1D,
        0x70, 0xE8, 0x76, 0x58, 0xC8, 0xB2, 0x91, 0xCE, 0x9C, 0xC3, 0xE9, 0x09, 0x7F, 0x2E, 0x47,
        0x97, 0xCC, 0x90, 0x39, 0x15, 0x35, 0x31, 0xDE, 0x1F, 0x0C, 0x8C, 0x0D, 0xC1, 0xC2, 0x92,
        0xBE, 0x97, 0xBF, 0x2F, 0x91, 0xA1, 0x8C, 0x7D, 0x50, 0xA8, 0x21, 0x2F, 0xD7, 0xA2, 0x9A,
        0x7E, 0xB5, 0xA7, 0x2A, 0x90, 0x02, 0xD9, 0xF3, 0x3D, 0xD1, 0xEB, 0xB8, 0xE0, 0x5A, 0x79,
        0x9E, 0x7D, 0x8D, 0xCA, 0x18, 0x6D, 0xBD, 0x9E, 0xA1, 0x80, 0x28, 0x6B, 0x2A, 0xFE, 0x51,
        0x24, 0x9B, 0x6F, 0x4D, 0x84, 0x77, 0x80, 0x23
    ])
    # d
    PrivateExponent = bytes([
        0x7F, 0x76, 0xCD, 0x0E, 0xE2, 0xD4, 0xDE, 0x05, 0x1C, 0xC6, 0xD9, 0xA8, 0x0E, 0x8D, 0xFA,
        0x7B, 0xCA, 0x1E, 0xAA, 0x27, 0x1A, 0x40, 0xF8, 0xF1, 0x22, 0x87, 0x35, 0xDD, 0xDB, 0xFD,
        0xEE, 0xF8, 0xC2, 0xBC, 0xBD, 0x01, 0xFB, 0x8B, 0xE2, 0x3E, 0x63, 0xB2, 0xB1, 0x22, 0x5C,
        0x56, 0x49, 0x6E, 0x11, 0xBE, 0x07, 0x44, 0x0B, 0x9A, 0x26, 0x66, 0xD1, 0x49, 0x2C, 0x8F,
        0xD3, 0x1B, 0xCF, 0xA4, 0xA1, 0xB8, 0xD1, 0xFB, 0xA4, 0x9E, 0xD2, 0x21, 0x28, 0x83, 0x09,
        0x8A, 0xF6, 0xA0, 0x0B, 0xA3, 0xD6, 0x0F, 0x9B, 0x63, 0x68, 0xCC, 0xBC, 0x0C, 0x4E, 0x14,
        0x5B, 0x27, 0xA4, 0xA9, 0xF4, 0x2B, 0xB9, 0xB8, 0x7B, 0xC0, 0xE6, 0x51, 0xAD, 0x1D, 0x77,
        0xD4, 0x6B, 0xB9, 0xCE, 0x20, 0xD1, 0x26, 0x66, 0x7E, 0x5E, 0x9E, 0xA2, 0xE9, 0x6B, 0x90,
        0xF3, 0x73, 0xB8, 0x52, 0x8F, 0x44, 0x11, 0x03, 0x0C, 0x13, 0x97, 0x39, 0x3D, 0x13, 0x22,
        0x58, 0xD5, 0x43, 0x82, 0x49, 0xDA, 0x6E, 0x7C, 0xA1, 0xC5, 0x8C, 0xA5, 0xB0, 0x09, 0xE0,
        0xCE, 0x3D, 0xDF, 0xF4, 0x9D, 0x3C, 0x97, 0x15, 0xE2, 0x6A, 0xC7, 0x2B, 0x3C, 0x50, 0x93,
        0x23, 0xDB, 0xBA, 0x4A, 0x22, 0x66, 0x44, 0xAC, 0x78, 0xBB, 0x0E, 0x1A, 0x27, 0x43, 0xB5,
        0x71, 0x67, 0xAF, 0xF4, 0xAB, 0x48, 0x46, 0x93, 0x73, 0xD0, 0x42, 0xAB, 0x93, 0x63, 0xE5,
        0x6C, 0x9A, 0xDE, 0x50, 0x24, 0xC0, 0x23, 0x7D, 0x99, 0x79, 0x3F, 0x22, 0x07, 0xE0, 0xC1,
        0x48, 0x56, 0x1B, 0xDF, 0x83, 0x09, 0x12, 0xB4, 0x2D, 0x45, 0x6B, 0xC9, 0xC0, 0x68, 0x85,
        0x99, 0x90, 0x79, 0x96, 0x1A, 0xD7, 0xF5, 0x4D, 0x1F, 0x37, 0x83, 0x40, 0x4A, 0xEC, 0x39,
        0x37, 0xA6, 0x80, 0x92, 0x7D, 0xC5, 0x80, 0xC7, 0xD6, 0x6F, 0xFE, 0x8A, 0x79, 0x89, 0xC6,
        0xB1
    ])

class DebugRifKeyset:
    # exponent1 = d mod (p - 1)
    Exponent1 = bytes([
        0xCD, 0x9A, 0x61, 0xB0, 0xB8, 0xD5, 0xB4, 0xE4, 0xE4, 0xF6, 0xAB, 0xF7, 0x27, 0xB7, 0x56,
        0x59, 0x6B, 0xB9, 0x11, 0xE7, 0xF4, 0x83, 0xAF, 0xB9, 0x73, 0x99, 0x7F, 0x49, 0xA2, 0x9C,
        0xF0, 0xB5, 0x6D, 0x37, 0x82, 0x14, 0x15, 0xF1, 0x04, 0x8A, 0xD4, 0x8E, 0xEB, 0x2E, 0x1F,
        0xE2, 0x81, 0xA9, 0x62, 0x6E, 0xB1, 0x68, 0x75, 0x62, 0xF3, 0x0F, 0xFE, 0xD4, 0x91, 0x87,
        0x98, 0x78, 0xBF, 0x26, 0xB5, 0x07, 0x58, 0xD0, 0xEE, 0x3F, 0x21, 0xE8, 0xC8, 0x0F, 0x5F,
        0xFA, 0x1C, 0x64, 0x74, 0x49, 0x52, 0xEB, 0xE7, 0xEE, 0xDE, 0xBA, 0x23, 0x26, 0x4A, 0xF6,
        0x9C, 0x1A, 0x09, 0x3F, 0xB9, 0x0B, 0x36, 0x26, 0x1A, 0xBE, 0xA9, 0x76, 0xE6, 0xF2, 0x69,
        0xDE, 0xFF, 0xAF, 0xCC, 0x0C, 0x9A, 0x66, 0x03, 0x86, 0x0A, 0x1F, 0x49, 0xA4, 0x10, 0xB6,
        0xBC, 0xC3, 0x7C, 0x88, 0xE8, 0xCE, 0x4B, 0xD9
    ])
    # exponent2 = d mod (q - 1)
    Exponent2 = bytes([
        0xB3, 0x73, 0xA3, 0x59, 0xE6, 0x97, 0xC0, 0xAB, 0x3B, 0x68, 0xFC, 0x39, 0xAC, 0xDB, 0x44,
        0xB1, 0xB4, 0x9E, 0x35, 0x4D, 0xBE, 0xC5, 0x36, 0x69, 0x6C, 0x3D, 0xC5, 0xFC, 0xFE, 0x4B,
        0x2F, 0xDC, 0x86, 0x80, 0x46, 0x96, 0x40, 0x1A, 0x0D, 0x6E, 0xFA, 0x8C, 0xE0, 0x47, 0x91,
        0xAC, 0xAD, 0x95, 0x2B, 0x8E, 0x1F, 0xF2, 0x0A, 0x45, 0xF8, 0x29, 0x95, 0x70, 0xC6, 0x88,
        0x5F, 0x71, 0x03, 0x99, 0x79, 0xBC, 0x84, 0x71, 0xBD, 0xE8, 0x84, 0x8C, 0x0E, 0xD4, 0x7B,
        0x30, 0x74, 0x57, 0x1A, 0x95, 0xE7, 0x90, 0x19, 0x8D, 0xAD, 0x8B, 0x4C, 0x4E, 0xC3, 0xE7,
        0x6B, 0x23, 0x86, 0x01, 0xEE, 0x9B, 0xE0, 0x2F, 0x15, 0xA2, 0x2C, 0x4C, 0x39, 0xD3, 0xDF,
        0x9C, 0x39, 0x01, 0xF1, 0x8C, 0x44, 0x4A, 0x15, 0x44, 0xDC, 0x51, 0xF7, 0x22, 0xD7, 0x7F,
        0x41, 0x7F, 0x68, 0xFA, 0xEE, 0x56, 0xE8, 0x05
    ])
    # e
    PublicExponent = bytes([0x00, 0x01, 0x00, 0x01])
    # (InverseQ)(q) = 1 mod p
    Coefficient = bytes([
        0xC0, 0x32, 0x43, 0xD3, 0x8C, 0x3D, 0xB4, 0xD2, 0x48, 0x8C, 0x42, 0x41, 0x24, 0x94, 0x6C,
        0x80, 0xC9, 0xC1, 0x79, 0x36, 0x7F, 0xAC, 0xC3, 0xFF, 0x6A, 0x25, 0xEB, 0x2C, 0xFB, 0xD4,
        0x2B, 0xA0, 0xEB, 0xFE, 0x25, 0xE9, 0xC6, 0x77, 0xCE, 0xFE, 0x2D, 0x23, 0xFE, 0xD0, 0xF4,
        0x0F, 0xD9, 0x7E, 0xD5, 0xA5, 0x7D, 0x1F, 0xC0, 0xE8, 0xE8, 0xEC, 0x80, 0x5B, 0xC7, 0xFD,
        0xE2, 0xBD, 0x94, 0xA6, 0x2B, 0xDD, 0x6A, 0x60, 0x45, 0x54, 0xAB, 0xCA, 0x42, 0x9C, 0x6A,
        0x6C, 0xBF, 0x3C, 0x84, 0xF9, 0xA5, 0x0E, 0x63, 0x0C, 0x51, 0x58, 0x62, 0x6D, 0x5A, 0xB7,
        0x3C, 0x3F, 0x49, 0x1A, 0xD0, 0x93, 0xB8, 0x4F, 0x1A, 0x6C, 0x5F, 0xC5, 0xE5, 0xA9, 0x75,
        0xD4, 0x86, 0x9E, 0xDF, 0x87, 0x0F, 0x27, 0xB0, 0x26, 0x78, 0x4E, 0xFB, 0xC1, 0x8A, 0x4A,
        0x24, 0x3F, 0x7F, 0x8F, 0x9A, 0x12, 0x51, 0xCB
    ])
    # n = p * q
    Modulus = bytes([
        0xC2, 0xD2, 0x44, 0xBC, 0xDD, 0x84, 0x3F, 0xD9, 0xC5, 0x22, 0xAF, 0xF7, 0xFC, 0x88, 0x8A,
        0x33, 0x80, 0xED, 0x8E, 0xE2, 0xCC, 0x81, 0xF7, 0xEC, 0xF8, 0x1C, 0x79, 0xBF, 0x02, 0xBB,
        0x12, 0x8E, 0x61, 0x68, 0x29, 0x1B, 0x15, 0xB6, 0x5E, 0xC6, 0xF8, 0xBF, 0x5A, 0xE0, 0x3B,
        0x6A, 0x6C, 0xD9, 0xD6, 0xF5, 0x75, 0xAB, 0xA0, 0x6F, 0x34, 0x81, 0x34, 0x9A, 0x5B, 0xAD,
        0xED, 0x31, 0xE3, 0xC6, 0xEA, 0x1A, 0xD1, 0x13, 0x22, 0xBB, 0xB3, 0xDA, 0xB3, 0xB2, 0x53,
        0xBD, 0x45, 0x79, 0x87, 0xAD, 0x0A, 0x01, 0x72, 0x18, 0x10, 0x29, 0x49, 0xF4, 0x41, 0x7F,
        0xD6, 0x47, 0x0C, 0x72, 0x92, 0x9E, 0xE9, 0xBB, 0x95, 0xA9, 0x5D, 0x79, 0xEB, 0xE4, 0x30,
        0x76, 0x90, 0x45, 0x4B, 0x9D, 0x9C, 0xCF, 0x92, 0x03, 0x60, 0x8C, 0x4B, 0x6C, 0xB3, 0x7A,
        0x3A, 0x05, 0x39, 0xA0, 0x66, 0xA9, 0x35, 0xCF, 0xB9, 0xFA, 0xAD, 0x9C, 0xAB, 0xEB, 0xE4,
        0x6A, 0x8C, 0xE9, 0x3B, 0xCC, 0x72, 0x12, 0x62, 0x63, 0xBD, 0x80, 0xC4, 0xEE, 0x37, 0x2B,
        0x32, 0x03, 0xA3, 0x09, 0xF7, 0xA0, 0x61, 0x57, 0xAD, 0x0D, 0xCF, 0x15, 0x98, 0x9E, 0x4E,
        0x49, 0xF8, 0xB5, 0xA3, 0x5C, 0x27, 0xEE, 0x45, 0x04, 0xEA, 0xE4, 0x4B, 0xBC, 0x8F, 0x87,
        0xED, 0x19, 0x1E, 0x46, 0x75, 0x63, 0xC4, 0x5B, 0xD5, 0xBC, 0x09, 0x2F, 0x02, 0x73, 0x19,
        0x3C, 0x58, 0x55, 0x49, 0x66, 0x4C, 0x11, 0xEC, 0x0F, 0x09, 0xFA, 0xA5, 0x56, 0x0A, 0x5A,
        0x63, 0x56, 0xAD, 0xA0, 0x0D, 0x86, 0x08, 0xC1, 0xE6, 0xB6, 0x13, 0x22, 0x49, 0x2F, 0x7C,
        0xDB, 0x4C, 0x56, 0x97, 0x0E, 0xC2, 0xD9, 0x2E, 0x87, 0xBC, 0x0E, 0x67, 0xC0, 0x1B, 0x58,
        0xBC, 0x64, 0x2B, 0xC2, 0x6E, 0xE2, 0x93, 0x2E, 0xB5, 0x6B, 0x70, 0xA4, 0x42, 0x9F, 0x64,
        0xC1
    ])
    # p
    Prime1 = bytes([
        0xE5, 0x62, 0xE1, 0x7F, 0x9F, 0x86, 0x08, 0xE2, 0x61, 0xD3, 0xD0, 0x42, 0xE2, 0xC4, 0xB6,
        0xA8, 0x51, 0x09, 0x19, 0x14, 0xA4, 0x3A, 0x11, 0x4C, 0x33, 0xA5, 0x9C, 0x01, 0x5E, 0x34,
        0xB6, 0x3F, 0x02, 0x1A, 0xCA, 0x47, 0xF1, 0x4F, 0x3B, 0x35, 0x2A, 0x07, 0x20, 0xEC, 0xD8,
        0xC1, 0x15, 0xD9, 0xCA, 0x03, 0x4F, 0xB8, 0xE8, 0x09, 0x73, 0x3F, 0x85, 0xB7, 0x41, 0xD5,
        0x51, 0x3E, 0x7B, 0xE3, 0x53, 0x2B, 0x48, 0x8B, 0x8E, 0xCB, 0xBA, 0xF7, 0xE0, 0x60, 0xF5,
        0x35, 0x0E, 0x6F, 0xB0, 0xD9, 0x2A, 0x99, 0xD0, 0xFF, 0x60, 0x14, 0xED, 0x40, 0xEA, 0xF8,
        0xD7, 0x0B, 0xC3, 0x8D, 0x8C, 0xE8, 0x81, 0xB3, 0x75, 0x93, 0x15, 0xB3, 0x7D, 0xF6, 0x39,
        0x60, 0x1A, 0x00, 0xE7, 0xC3, 0x27, 0xAD, 0xA4, 0x33, 0xD5, 0x3E, 0xA4, 0x35, 0x48, 0x6F,
        0x22, 0xEF, 0x5D, 0xDD, 0x7D, 0x7B, 0x61, 0x05
    ])
    # q
    Prime2 = bytes([
        0xD9, 0x6C, 0xC2, 0x0C, 0xF7, 0xAE, 0xD1, 0xF3, 0x3B, 0x3B, 0x49, 0x1E, 0x9F, 0x12, 0x9C,
        0xA1, 0x78, 0x1F, 0x35, 0x1D, 0x98, 0x26, 0x13, 0x71, 0xF9, 0x09, 0xFD, 0xF0, 0xAD, 0x38,
        0x55, 0xB7, 0xEE, 0x61, 0x04, 0x72, 0x51, 0x87, 0x2E, 0x05, 0x84, 0xB1, 0x1D, 0x0C, 0x0D,
        0xDB, 0xD4, 0x25, 0x3E, 0x26, 0xED, 0xEA, 0xB8, 0xF7, 0x49, 0xFE, 0xA2, 0x94, 0xE6, 0xF2,
        0x08, 0x92, 0xA7, 0x85, 0xF5, 0x30, 0xB9, 0x84, 0x22, 0xBF, 0xCA, 0xF0, 0x5F, 0xCB, 0x31,
        0x20, 0x34, 0x49, 0x16, 0x76, 0x34, 0xCC, 0x7A, 0xCB, 0x96, 0xFE, 0x78, 0x7A, 0x41, 0xFE,
        0x9A, 0xA2, 0x23, 0xF7, 0x68, 0x80, 0xD6, 0xCE, 0x4A, 0x78, 0xA5, 0xB7, 0x05, 0x77, 0x81,
        0x1F, 0xDE, 0x5E, 0xA8, 0x6E, 0x3E, 0x87, 0xEC, 0x44, 0xD2, 0x69, 0xC6, 0x54, 0x91, 0x6B,
        0x5E, 0x13, 0x8A, 0x03, 0x87, 0x05, 0x31, 0x8D
    ])
    # d
    PrivateExponent = bytes([
        0x01, 0x61, 0xAD, 0xD8, 0x9C, 0x06, 0x89, 0xD0, 0x60, 0xC8, 0x41, 0xF0, 0xB3, 0x83, 0x01,
        0x5D, 0xE3, 0xA2, 0x6B, 0xA2, 0xBA, 0x9A, 0x0A, 0x58, 0xCD, 0x1A, 0xA0, 0x97, 0x64, 0xEC,
        0xD0, 0x31, 0x1F, 0xCA, 0x36, 0x0E, 0x69, 0xDD, 0x40, 0xF7, 0x4E, 0xC0, 0xC6, 0xA3, 0x73,
        0xF0, 0x69, 0x84, 0xB2, 0xF4, 0x4B, 0x29, 0x14, 0x2A, 0x6D, 0xB8, 0x23, 0xD8, 0x1B, 0x61,
        0xD4, 0x9E, 0x87, 0xB3, 0xBB, 0xA9, 0xC4, 0x85, 0x4A, 0xF8, 0x03, 0x4A, 0xBF, 0xFE, 0xF9,
        0xFE, 0x8B, 0xDD, 0x54, 0x83, 0xBA, 0xE0, 0x2F, 0x3F, 0xB1, 0xEF, 0xA5, 0x05, 0x5D, 0x28,
        0x8B, 0xAB, 0xB5, 0xD0, 0x23, 0x2F, 0x8A, 0xCF, 0x48, 0x7C, 0xAA, 0xBB, 0xC8, 0x5B, 0x36,
        0x27, 0xC5, 0x16, 0xA4, 0xB6, 0x61, 0xAC, 0x0C, 0x28, 0x47, 0x79, 0x3F, 0x38, 0xAE, 0x5E,
        0x25, 0xC6, 0xAF, 0x35, 0xAE, 0xBC, 0xB0, 0xF3, 0xBC, 0xBD, 0xFD, 0xA4, 0x87, 0x0D, 0x14,
        0x3D, 0x90, 0xE4, 0xDE, 0x5D, 0x1D, 0x46, 0x81, 0xF1, 0x28, 0x6D, 0x2F, 0x2C, 0x5E, 0x97,
        0x2D, 0x89, 0x2A, 0x51, 0x72, 0x3C, 0x20, 0x02, 0x59, 0xB1, 0x98, 0x93, 0x05, 0x1E, 0x3F,
        0xA1, 0x8A, 0x69, 0x30, 0x0E, 0x70, 0x84, 0x8B, 0xAE, 0x97, 0xA1, 0x08, 0x95, 0x63, 0x4C,
        0xC7, 0xE8, 0x5D, 0x59, 0xCA, 0x78, 0x2A, 0x23, 0x87, 0xAC, 0x6F, 0x04, 0x33, 0xB1, 0x61,
        0xB9, 0xF0, 0x95, 0xDA, 0x33, 0xCC, 0xE0, 0x4C, 0x82, 0x68, 0x82, 0x14, 0x51, 0xBE, 0x49,
        0x1C, 0x58, 0xA2, 0x8B, 0x05, 0x4E, 0x98, 0x37, 0xEB, 0x94, 0x0B, 0x01, 0x22, 0xDC, 0xB3,
        0x19, 0xCA, 0x77, 0xA6, 0x6E, 0x97, 0xFF, 0x8A, 0x53, 0x5A, 0xC5, 0x24, 0xE4, 0xAF, 0x6E,
        0xA8, 0x2B, 0x53, 0xA4, 0xBE, 0x96, 0xA5, 0x7B, 0xCE, 0x22, 0x56, 0xA3, 0xF1, 0xCF, 0x14,
        0xA5
    ])

class PkgDerivedKey3Keyset:
    # exponent1 = d mod (p - 1)
    Exponent1 = bytes([
        0x52, 0xCC, 0x2D, 0xA0, 0x9C, 0x9E, 0x75, 0xE7, 0x28, 0xEE, 0x3D, 0xDE, 0xE3, 0x45, 0xD1,
        0x4F, 0x94, 0x1C, 0xCC, 0xC8, 0x87, 0x29, 0x45, 0x3B, 0x8D, 0x6E, 0xAB, 0x6E, 0x2A, 0xA7,
        0xC7, 0x15, 0x43, 0xA3, 0x04, 0x8F, 0x90, 0x5F, 0xEB, 0xF3, 0x38, 0x4A, 0x77, 0xFA, 0x36,
        0xB7, 0x15, 0x76, 0xB6, 0x01, 0x1A, 0x8E, 0x25, 0x87, 0x82, 0xF1, 0x55, 0xD8, 0xC6, 0x43,
        0x2A, 0xC0, 0xE5, 0x98, 0xC9, 0x32, 0xD1, 0x94, 0x6F, 0xD9, 0x01, 0xBA, 0x06, 0x81, 0xE0,
        0x6D, 0x88, 0xF2, 0x24, 0x2A, 0x25, 0x01, 0x64, 0x5C, 0xBF, 0xF2, 0xD9, 0x99, 0x67, 0x3E,
        0xF6, 0x72, 0xEE, 0xE4, 0xE2, 0x33, 0x5C, 0xF8, 0x00, 0x40, 0xE3, 0x2A, 0x9A, 0xF4, 0x3D,
        0x22, 0x86, 0x44, 0x3C, 0xFB, 0x0A, 0xA5, 0x7C, 0x3F, 0xCC, 0xF5, 0xF1, 0x16, 0xC4, 0xAC,
        0x88, 0xB4, 0xDE, 0x62, 0x94, 0x92, 0x6A, 0x13
    ])
    # exponent2 = d mod (q - 1)
    Exponent2 = bytes([
        0x7C, 0x9D, 0xAD, 0x39, 0xE0, 0xD5, 0x60, 0x14, 0x94, 0x48, 0x19, 0x7F, 0x88, 0x95, 0xD5,
        0x8B, 0x80, 0xAD, 0x85, 0x8A, 0x4B, 0x77, 0x37, 0x85, 0xD0, 0x77, 0xBB, 0xBF, 0x89, 0x71,
        0x4A, 0x72, 0xCB, 0x72, 0x68, 0x38, 0xEC, 0x02, 0xC6, 0x7D, 0xC6, 0x44, 0x06, 0x33, 0x51,
        0x1C, 0xC0, 0xFF, 0x95, 0x8F, 0x0D, 0x75, 0xDC, 0x25, 0xBB, 0x0B, 0x73, 0x91, 0xA9, 0x6D,
        0x42, 0xD8, 0x03, 0xB7, 0x68, 0xD4, 0x1E, 0x75, 0x62, 0xA3, 0x70, 0x35, 0x79, 0x78, 0x00,
        0xC8, 0xF5, 0xEF, 0x15, 0xB9, 0xFC, 0x4E, 0x47, 0x5A, 0xC8, 0x70, 0x70, 0x5B, 0x52, 0x98,
        0xC0, 0xC2, 0x58, 0x4A, 0x70, 0x96, 0xCC, 0xB8, 0x10, 0xE1, 0x2F, 0x78, 0x8B, 0x2B, 0xA1,
        0x7F, 0xF9, 0xAC, 0xDE, 0xF0, 0xBB, 0x2B, 0xE2, 0x66, 0xE3, 0x22, 0x92, 0x31, 0x21, 0x57,
        0x92, 0xC4, 0xB8, 0xF2, 0x3E, 0x76, 0x20, 0x37
    ])
    # e
    PublicExponent = bytes([0, 1, 0, 1])
    # (InverseQ)(q) = 1 mod p
    Coefficient = bytes([
        0x45, 0x97, 0x55, 0xD4, 0x22, 0x08, 0x5E, 0xF3, 0x5C, 0xB4, 0x05, 0x7A, 0xFD, 0xAA, 0x42,
        0x42, 0xAD, 0x9A, 0x8C, 0xA0, 0x6C, 0xBB, 0x1D, 0x68, 0x54, 0x54, 0x6E, 0x3E, 0x32, 0xE3,
        0x53, 0x73, 0x76, 0xF1, 0x3E, 0x01, 0xEA, 0xD3, 0xCF, 0xEB, 0xEB, 0x23, 0x3E, 0xC0, 0xBE,
        0xCE, 0xEC, 0x2C, 0x89, 0x5F, 0xA8, 0x27, 0x3A, 0x4C, 0xB7, 0xE6, 0x74, 0xBC, 0x45, 0x4C,
        0x26, 0xC8, 0x25, 0xFF, 0x34, 0x63, 0x25, 0x37, 0xE1, 0x48, 0x10, 0xC1, 0x93, 0xA6, 0xAF,
        0xEB, 0xBA, 0xE3, 0xA2, 0xF1, 0x3D, 0xEF, 0x63, 0xD8, 0xF4, 0xFD, 0xD3, 0xEE, 0xE2, 0x5D,
        0xE9, 0x33, 0xCC, 0xAD, 0xBA, 0x75, 0x5C, 0x85, 0xAF, 0xCE, 0xA9, 0x3D, 0xD1, 0xA2, 0x17,
        0xF3, 0xF6, 0x98, 0xB3, 0x50, 0x8E, 0x5E, 0xF6, 0xEB, 0x02, 0x8E, 0xA1, 0x62, 0xA7, 0xD6,
        0x2C, 0xEC, 0x91, 0xFF, 0x15, 0x40, 0xD2, 0xE3
    ])
    # n = p * q
    Modulus = bytes([
        0xd2, 0x12, 0xfc, 0x33, 0x5f, 0x6d, 0xdb, 0x83, 0x16, 0x09, 0x62, 0x8b, 0x03, 0x56, 0x27,
        0x37, 0x82, 0xd4, 0x77, 0x85, 0x35, 0x29, 0x39, 0x2d, 0x52, 0x6b, 0x8c, 0x4c, 0x8c, 0xfb,
        0x06, 0xc1, 0x84, 0x5b, 0xe7, 0xd4, 0xf7, 0xbc, 0xd2, 0x4e, 0x62, 0x45, 0xcd, 0x2a, 0xbb,
        0xd7, 0x77, 0x76, 0x45, 0x36, 0x55, 0x27, 0x3f, 0xb3, 0xf5, 0xf9, 0x8e, 0xda, 0x4b, 0xef,
        0xaa, 0x59, 0xae, 0xb3, 0x9b, 0xea, 0x54, 0x98, 0xd2, 0x06, 0x32, 0x6a, 0x58, 0x31, 0x2a,
        0xe0, 0xd4, 0x4f, 0x90, 0xb5, 0x0a, 0x7d, 0xec, 0xf4, 0x3a, 0x9c, 0x52, 0x67, 0x2d, 0x99,
        0x31, 0x8e, 0x0c, 0x43, 0xe6, 0x82, 0xfe, 0x07, 0x46, 0xe1, 0x2e, 0x50, 0xd4, 0x1f, 0x2d,
        0x2f, 0x7e, 0xd9, 0x08, 0xba, 0x06, 0xb3, 0xbf, 0x2e, 0x20, 0x3f, 0x4e, 0x3f, 0xfe, 0x44,
        0xff, 0xaa, 0x50, 0x43, 0x57, 0x91, 0x69, 0x94, 0x49, 0x15, 0x82, 0x82, 0xe4, 0x0f, 0x4c,
        0x8d, 0x9d, 0x2c, 0xc9, 0x5b, 0x1d, 0x64, 0xbf, 0x88, 0x8b, 0xd4, 0xc5, 0x94, 0xe7, 0x65,
        0x47, 0x84, 0x1e, 0xe5, 0x79, 0x10, 0xfb, 0x98, 0x93, 0x47, 0xb9, 0x7d, 0x85, 0x12, 0xa6,
        0x40, 0x98, 0x2c, 0xf7, 0x92, 0xbc, 0x95, 0x19, 0x32, 0xed, 0xe8, 0x90, 0x56, 0x0d, 0x65,
        0xc1, 0xaa, 0x78, 0xc6, 0x2e, 0x54, 0xfd, 0x5f, 0x54, 0xa1, 0xf6, 0x7e, 0xe5, 0xe0, 0x5f,
        0x61, 0xc1, 0x20, 0xb4, 0xb9, 0xb4, 0x33, 0x08, 0x70, 0xe4, 0xdf, 0x89, 0x56, 0xed, 0x01,
        0x29, 0x46, 0x77, 0x5f, 0x8c, 0xb8, 0xa9, 0xf5, 0x1e, 0x2e, 0xb3, 0xb9, 0xbf, 0xe0, 0x09,
        0xb7, 0x8d, 0x28, 0xd4, 0xa6, 0xc3, 0xb8, 0x1e, 0x1f, 0x07, 0xeb, 0xb4, 0x12, 0x0b, 0x95,
        0xb8, 0x85, 0x30, 0xfd, 0xdc, 0x39, 0x13, 0xd0, 0x7c, 0xdc, 0x8f, 0xed, 0xf9, 0xc9, 0xa3,
        0xc1
    ])
    # p
    Prime1 = bytes([
        0xF9, 0x67, 0xAD, 0x99, 0x12, 0x31, 0x0C, 0x56, 0xA2, 0x2E, 0x16, 0x1C, 0x46, 0xB3, 0x4D,
        0x5B, 0x43, 0xBE, 0x42, 0xA2, 0xF6, 0x86, 0x96, 0x80, 0x42, 0xC3, 0xC7, 0x3F, 0xC3, 0x42,
        0xF5, 0x87, 0x49, 0x33, 0x9F, 0x07, 0x5D, 0x6E, 0x2C, 0x04, 0xFD, 0xE3, 0xE1, 0xB2, 0xAE,
        0x0A, 0x0C, 0xF0, 0xC7, 0xA6, 0x1C, 0xA1, 0x63, 0x50, 0xC8, 0x09, 0x9C, 0x51, 0x24, 0x52,
        0x6C, 0x5E, 0x5E, 0xBD, 0x1E, 0x27, 0x06, 0xBB, 0xBC, 0x9E, 0x94, 0xE1, 0x35, 0xD4, 0x6D,
        0xB3, 0xCB, 0x3C, 0x68, 0xDD, 0x68, 0xB3, 0xFE, 0x6C, 0xCB, 0x8D, 0x82, 0x20, 0x76, 0x23,
        0x63, 0xB7, 0xE9, 0x68, 0x10, 0x01, 0x4E, 0xDC, 0xBA, 0x27, 0x5D, 0x01, 0xC1, 0x2D, 0x80,
        0x5E, 0x2B, 0xAF, 0x82, 0x6B, 0xD8, 0x84, 0xB6, 0x10, 0x52, 0x86, 0xA7, 0x89, 0x8E, 0xAE,
        0x9A, 0xE2, 0x89, 0xC6, 0xF7, 0xD5, 0x87, 0xFB
    ])
    # q
    Prime2 = bytes([
        0xD7, 0xA1, 0x0F, 0x9A, 0x8B, 0xF2, 0xC9, 0x11, 0x95, 0x32, 0x9A, 0x8C, 0xF0, 0xD9, 0x40,
        0x47, 0xF5, 0x68, 0xA0, 0x0D, 0xBD, 0xC1, 0xFC, 0x43, 0x2F, 0x65, 0xF9, 0xC3, 0x61, 0x0F,
        0x25, 0x77, 0x54, 0xAD, 0xD7, 0x58, 0xAC, 0x84, 0x40, 0x60, 0x8D, 0x3F, 0xF3, 0x65, 0x89,
        0x75, 0xB5, 0xC6, 0x2C, 0x51, 0x1A, 0x2F, 0x1F, 0x22, 0xE4, 0x43, 0x11, 0x54, 0xBE, 0xC9,
        0xB4, 0xC7, 0xB5, 0x1B, 0x05, 0x0B, 0xBC, 0x56, 0x9A, 0xCD, 0x4A, 0xD9, 0x73, 0x68, 0x5E,
        0x5C, 0xFB, 0x92, 0xB7, 0x8B, 0x0D, 0xFF, 0xF5, 0x07, 0xCA, 0xB4, 0xC8, 0x9B, 0x96, 0x3C,
        0x07, 0x9E, 0x3E, 0x6B, 0x2A, 0x11, 0xF2, 0x8A, 0xB1, 0x8A, 0xD7, 0x2E, 0x1B, 0xA5, 0x53,
        0x24, 0x06, 0xED, 0x50, 0xB8, 0x90, 0x67, 0xB1, 0xE2, 0x41, 0xC6, 0x92, 0x01, 0xEE, 0x10,
        0xF0, 0x61, 0xBB, 0xFB, 0xB2, 0x7D, 0x4A, 0x73
    ])
    # d
    PrivateExponent = bytes([
        0x32, 0xD9, 0x03, 0x90, 0x8F, 0xBD, 0xB0, 0x8F, 0x57, 0x2B, 0x28, 0x5E, 0x0B, 0x8D, 0xB3,
        0xEA, 0x5C, 0xD1, 0x7E, 0xA8, 0x90, 0x88, 0x8C, 0xDD, 0x6A, 0x80, 0xBB, 0xB1, 0xDF, 0xC1,
        0xF7, 0x0D, 0xAA, 0x32, 0xF0, 0xB7, 0x7C, 0xCB, 0x88, 0x80, 0x0E, 0x8B, 0x64, 0xB0, 0xBE,
        0x4C, 0xD6, 0x0E, 0x9B, 0x8C, 0x1E, 0x2A, 0x64, 0xE1, 0xF3, 0x5C, 0xD7, 0x76, 0x01, 0x41,
        0x5E, 0x93, 0x5C, 0x94, 0xFE, 0xDD, 0x46, 0x62, 0xC3, 0x1B, 0x5A, 0xE2, 0xA0, 0xBC, 0x2D,
        0xEB, 0xC3, 0x98, 0x0A, 0xA7, 0xB7, 0x85, 0x69, 0x70, 0x68, 0x2B, 0x64, 0x4A, 0xB3, 0x1F,
        0xCC, 0x7D, 0xDC, 0x7C, 0x26, 0xF4, 0x77, 0xF6, 0x5C, 0xF2, 0xAE, 0x5A, 0x44, 0x2D, 0xD3,
        0xAB, 0x16, 0x62, 0x04, 0x19, 0xBA, 0xFB, 0x90, 0xFF, 0xE2, 0x30, 0x50, 0x89, 0x6E, 0xCB,
        0x56, 0xB2, 0xEB, 0xC0, 0x91, 0x16, 0x92, 0x5E, 0x30, 0x8E, 0xAE, 0xC7, 0x94, 0x5D, 0xFD,
        0x35, 0xE1, 0x20, 0xF8, 0xAD, 0x3E, 0xBC, 0x08, 0xBF, 0xC0, 0x36, 0x74, 0x9F, 0xD5, 0xBB,
        0x52, 0x08, 0xFD, 0x06, 0x66, 0xF3, 0x7A, 0xB3, 0x04, 0xF4, 0x75, 0x29, 0x5D, 0xE9, 0x5F,
        0xAA, 0x10, 0x30, 0xB2, 0x0F, 0x5A, 0x1A, 0xC1, 0x2A, 0xB3, 0xFE, 0xCB, 0x21, 0xAD, 0x80,
        0xEC, 0x8F, 0x20, 0x09, 0x1C, 0xDB, 0xC5, 0x58, 0x94, 0xC2, 0x9C, 0xC6, 0xCE, 0x82, 0x65,
        0x3E, 0x57, 0x90, 0xBC, 0xA9, 0x8B, 0x06, 0xB4, 0xF0, 0x72, 0xF6, 0x77, 0xDF, 0x98, 0x64,
        0xF1, 0xEC, 0xFE, 0x37, 0x2D, 0xBC, 0xAE, 0x8C, 0x08, 0x81, 0x1F, 0xC3, 0xC9, 0x89, 0x1A,
        0xC7, 0x42, 0x82, 0x4B, 0x2E, 0xDC, 0x8E, 0x8D, 0x73, 0xCE, 0xB1, 0xCC, 0x01, 0xD9, 0x08,
        0x70, 0x87, 0x3C, 0x44, 0x08, 0xEC, 0x49, 0x8F, 0x81, 0x5A, 0xE2, 0x40, 0xFF, 0x77, 0xFC,
        0x0D
    ])

# AES and XTS related utility functions

# AES and XTS related utility functions
def xts_xor_block(a, b):
    """XOR two blocks, used in XTS mode decryption"""
    return bytes(x ^ y for x, y in zip(a, b))

def xts_mult(tweak):
    """Multiply by x in GF(2^128) for XTS mode"""
    # Convert the tweak to a list for easier manipulation
    tweak_list = list(tweak)
    feedback = 0

    for i in range(len(tweak_list)):
        tmp = (tweak_list[i] >> 7) & 1
        tweak_list[i] = ((tweak_list[i] << 1) + feedback) & 0xFF
        feedback = tmp

    if feedback != 0:
        tweak_list[0] ^= 0x87

    return bytes(tweak_list)

class Crypto:
    @staticmethod
    def initialize_rsa_key(is_dk3=True):
        """Initialize RSA key using proper components from keys.h"""
        try:
            if is_dk3:
                # Use PkgDerivedKey3Keyset for DK3
                keyset = PkgDerivedKey3Keyset
            else:
                # Use FakeKeyset for EKPFS
                keyset = FakeKeyset

            # Convert key components to integers
            n = bytes_to_long(keyset.Prime1) * bytes_to_long(keyset.Prime2)
            e = bytes_to_long(keyset.PublicExponent)
            d = bytes_to_long(keyset.PrivateExponent)
            p = bytes_to_long(keyset.Prime1)
            q = bytes_to_long(keyset.Prime2)

            # Create the RSA key components
            key_components = {
                'n': n,
                'e': e,
                'd': d,
                'p': p,
                'q': q
            }

            # Create and return the RSA key
            return RSA.construct(key_components)
        except Exception as e:
            print(f"Warning: Failed to initialize RSA key: {e}")
            print("Falling back to simplified RSA simulation")
            return None

    @staticmethod
    def rsa2048_decrypt(ciphertext, is_dk3=True):
        """Decrypt using RSA-2048 with the appropriate keyset

        This attempts to use proper RSA decryption with the keys from keys.h.
        If that fails (e.g., truncated keys or import issues), it falls back
        to a simplified hash-based implementation.
        """
        # Try to use proper RSA decryption
        try:
            key = Crypto.initialize_rsa_key(is_dk3)
            if key is not None:
                # Convert ciphertext to integer
                ciphertext_int = bytes_to_long(ciphertext)

                # Perform RSA decryption (m = c^d mod n)
                plaintext_int = pow(ciphertext_int, key.d, key.n)

                # Convert back to bytes with proper PKCS#1 v1.5 handling
                plaintext = long_to_bytes(plaintext_int)

                # The decrypted data should include PKCS#1 v1.5 padding
                # For now, we'll just return the last 32 bytes as the key
                return plaintext[-32:] if len(plaintext) >= 32 else plaintext

        except Exception as e:
            print(f"Warning: RSA decryption failed: {e}")
            print("Using hash-based simulation as fallback")

        # Fall back to the simplified hash-based implementation
        if is_dk3:
            # For DK3 key (entry key #3)
            key_seed = b"PkgDerivedKey3" + ciphertext[:16]
            result = hashlib.sha256(key_seed).digest()
        else:
            # For EKPFS key (from IMAGE_KEY)
            key_seed = b"FakeKeyset" + ciphertext[:16]
            result = hashlib.sha256(key_seed).digest()

        return result

    @staticmethod
    def iv_key_hash256(cipher_input):
        """Compute SHA-256 hash of the input, used for IV key derivation"""
        sha256 = SHA256.new()
        sha256.update(cipher_input)
        return sha256.digest()

    @staticmethod
    def aes_cbc_cfb128_decrypt(ivkey, ciphertext):
        """Decrypt using AES-CBC with the provided IV and key"""
        key = ivkey[16:32]  # Second half of ivkey is the actual key
        iv = ivkey[:16]     # First half of ivkey is the IV

        cipher = AES.new(key, AES.MODE_CBC, iv)
        return cipher.decrypt(ciphertext)

    @staticmethod
    def pfs_gen_crypto_key(ekpfs, seed):
        """Generate data and tweak keys for PFS decryption"""
        # Create an HMAC with ekpfs as the key
        hmac = HMAC.new(ekpfs, digestmod=SHA256)

        # Prepare the data: 4 bytes for index (value 1) followed by the seed
        data = struct.pack("<I", 1) + seed

        # Calculate the HMAC
        data_tweak_key = hmac.update(data).digest()

        # Split the result into tweak key and data key
        tweak_key = data_tweak_key[:16]
        data_key = data_tweak_key[16:32]

        return data_key, tweak_key

    @staticmethod
    def decrypt_pfs(data_key, tweak_key, src_image, start_sector=0):
        """Decrypt PFS image using XTS mode with the provided keys"""
        # Allocate buffer for decrypted image
        dst_image = bytearray(len(src_image))

        # Process the image in 4KB (0x1000) blocks
        for i in range(0, len(src_image), 0x1000):
            current_sector = start_sector + (i // 0x1000)

            # Initialize tweak as the sector number
            tweak = struct.pack("<Q", current_sector) + bytes(8)  # 8 bytes for sector + 8 bytes of zeros

            # Encrypt the tweak using ECB mode
            encrypt_cipher = AES.new(tweak_key, AES.MODE_ECB)
            encrypted_tweak = encrypt_cipher.encrypt(tweak)

            # Decrypt the 4KB block in 16-byte chunks
            decrypt_cipher = AES.new(data_key, AES.MODE_ECB)

            for offset in range(0, min(0x1000, len(src_image) - i), 16):
                block_offset = i + offset
                if block_offset + 16 > len(src_image):
                    break

                # XOR the ciphertext with the encrypted tweak
                xor_buffer = xts_xor_block(src_image[block_offset:block_offset+16], encrypted_tweak)

                # Decrypt the result
                decrypted = decrypt_cipher.decrypt(xor_buffer)

                # XOR again with the encrypted tweak to get plaintext
                plaintext = xts_xor_block(decrypted, encrypted_tweak)

                # Copy to the destination buffer
                dst_image[block_offset:block_offset+16] = plaintext

                # Update the encrypted tweak for the next block
                encrypted_tweak = xts_mult(encrypted_tweak)

        return bytes(dst_image)

class PKGExtractor:
    def __init__(self):
        self.header = None
        self.title_id = ""
        self.pkg_path = None
        self.extract_path = None
        self.inodes = []
        self.fs_table = []
        self.extract_paths = {}
        self.current_dir = None
        self.pkg_entries = []
        self.pkg_content_offset = 0
        self.pkg_content_size = 0
        self.pkg_table_entry_offset = 0
        self.pkg_table_entry_count = 0
        self.sfo_data = None
        self.verbose = False
        self.seed_digest = None
        self.digest1 = []
        self.key1 = []
        self.dk3 = None
        self.imgkeydata = None
        self.imgkey = None
        self.ekpfs_key = None

    def open(self, pkg_path):
        """Open and validate the PKG file, parse header and entries"""
        # Expand the user directory in the path
        self.pkg_path = Path(pkg_path).expanduser()
        if not self.pkg_path.is_file():
            print(f"Error: PKG file not found at {self.pkg_path}")
            return False

        try:
            with open(self.pkg_path, 'rb') as f:
                # Read and verify PKG header magic
                magic_bytes = f.read(4)
                if not magic_bytes or len(magic_bytes) < 4:
                    print("Error: Could not read magic bytes from PKG file.")
                    return False

                # Use big-endian for magic number check
                magic = struct.unpack(">I", magic_bytes)[0]
                if magic != PKG_MAGIC:
                    print(f"Error: Not a valid PS4 PKG file (invalid magic: expected {hex(PKG_MAGIC)}, got {hex(magic)})")
                    return False

                f.seek(0) # Resets file pointer
                self.header = f.read(0x1000)  # PKG header is usually 4KB
                if len(self.header) < 0x1000: # Check if header read was successful
                    print("Warning: PKG header seems smaller than expected.")

                # Parse header fields (assuming these are little-endian)
                f.seek(0x10) # Seeks to offset 0x10
                self.pkg_content_offset = struct.unpack("<I", f.read(4))[0]
                self.pkg_content_size = struct.unpack("<I", f.read(4))[0]
                f.seek(0x30) # Seeks to offset 0x30
                self.pkg_table_entry_offset = struct.unpack("<I", f.read(4))[0]
                self.pkg_table_entry_count = struct.unpack("<I", f.read(4))[0]
                # Add these lines for debugging:
                if self.verbose:
                    print(f"DEBUG: PKG Table Entry Offset: {hex(self.pkg_table_entry_offset)}")
                    print(f"DEBUG: PKG Table Entry Count: {self.pkg_table_entry_count}")
                # Extract title ID from content_id (offset 0x47, length 9)
                f.seek(0x47) # Seeks to offset 0x47
                self.title_id = f.read(9).decode('utf-8', errors='ignore')
                if self.verbose:
                    print(f"Found PKG with Title ID: {self.title_id}")
                # Parse PKG table entries
                self.pkg_entries = []
                f.seek(self.pkg_table_entry_offset) # Seeks to the table offset read earlier
                for i in range(self.pkg_table_entry_count):
                    try:
                        entry = self._parse_pkg_entry(f)
                        self.pkg_entries.append(entry)
                        # Add this line for debugging:
                        if self.verbose:
                            print(f"  Parsed Entry {i}: ID={hex(entry['id'])}, Offset={hex(entry['offset'])}, Size={hex(entry['size'])}")
                    except struct.error as e:
                        print(f"Error parsing PKG entry {i}: {e}. Possibly truncated file or incorrect table offset.")
                        return False
                return True
        except FileNotFoundError:
            print(f"Error: PKG file not found at {self.pkg_path}")
            return False
        except Exception as e:
            print(f"An unexpected error occurred while opening the PKG: {e}")
            return False

    def _parse_pkg_entry(self, f):
        """Parse a single PKG table entry (simplified)"""
        entry = {}
        entry['id'] = struct.unpack('<I', f.read(4))[0]
        entry['filename_offset'] = struct.unpack('<I', f.read(4))[0]
        entry['flags1'] = struct.unpack('<I', f.read(4))[0]
        entry['flags2'] = struct.unpack('<I', f.read(4))[0]
        entry['offset'] = struct.unpack('<Q', f.read(8))[0]
        entry['size'] = struct.unpack('<Q', f.read(8))[0]
        f.read(8)  # skip reserved
        return entry

    def extract_all_entries(self):
        """Extract all known entries to their correct locations"""
        with open(self.pkg_path, 'rb') as f:
            for entry in self.pkg_entries:
                # Only extract known files for now
                if entry['id'] in PKG_ENTRY_ID_TO_NAME:
                    rel_path = PKG_ENTRY_ID_TO_NAME[entry['id']]
                    out_path = self.extract_path / "sce_sys" / rel_path
                    os.makedirs(out_path.parent, exist_ok=True)
                    f.seek(entry['offset'])
                    data = f.read(entry['size'])

                    # Handle decryption for certain files
                    if entry['id'] in [0x400, 0x401, 0x402, 0x403]:  # Special handling for encrypted entries
                        if self.dk3 is not None:
                            concatenated_ivkey_dk3 = entry['id'].to_bytes(4, byteorder='little') + bytes(60) + self.dk3
                            ivkey = Crypto.iv_key_hash256(concatenated_ivkey_dk3)
                            data = Crypto.aes_cbc_cfb128_decrypt(ivkey, data)

                    with open(out_path, 'wb') as out:
                        out.write(data)
                    if self.verbose:
                        print(f"Extracted {rel_path} to {out_path}")

                # Process key entries
                if entry['id'] == 0x10:  # ENTRY_KEYS
                    f.seek(entry['offset'])
                    self.seed_digest = f.read(32)
                    self.digest1 = [f.read(32) for _ in range(7)]
                    self.key1 = [f.read(32) for _ in range(7)]
                    # Decrypt DK3 using the third key
                    self.dk3 = Crypto.rsa2048_decrypt(self.key1[3], is_dk3=True)
                    if self.verbose:
                        print("Processed entry keys, extracted DK3")

                elif entry['id'] == 0x20:  # IMAGE_KEY
                    f.seek(entry['offset'])
                    self.imgkeydata = f.read(entry['size'])
                    if self.dk3 is not None:
                        # The concatenated iv + dk3 for HASH256
                        concatenated_ivkey_dk3 = entry['id'].to_bytes(4, byteorder='little') + bytes(60) + self.dk3
                        ivkey = Crypto.iv_key_hash256(concatenated_ivkey_dk3)
                        self.imgkey = Crypto.aes_cbc_cfb128_decrypt(ivkey, self.imgkeydata)
                        # Decrypt ekpfs key
                        self.ekpfs_key = Crypto.rsa2048_decrypt(self.imgkey, is_dk3=False)
                        if self.verbose:
                            print("Processed image key, extracted EKPFS key")

    def extract_pfs_image(self):
        """
        Extract and decrypt the PFS image from the PKG, decompress PFSC sectors,
        and extract the file system structure.
        """
        # Locate PFS image offset and size from header
        with open(self.pkg_path, 'rb') as f:
            # The following offsets are based on the C++ PKGHeader struct
            f.seek(0x70)  # pfs_image_offset
            pfs_image_offset = struct.unpack('<Q', f.read(8))[0]
            pfs_image_size = struct.unpack('<Q', f.read(8))[0]
            if self.verbose:
                print(f"PFS image offset: {hex(pfs_image_offset)}, size: {hex(pfs_image_size)}")

            # Read the encrypted PFS image
            f.seek(pfs_image_offset)
            pfs_encrypted = f.read(pfs_image_size)

            # Read the seed at offset 0x370 in the PFS image
            f.seek(pfs_image_offset + 0x370)
            seed = f.read(16)

            if self.verbose:
                print(f"Read seed from offset {hex(pfs_image_offset + 0x370)}")

            # Generate data and tweak keys from the EKPFS key and seed
            if self.ekpfs_key is not None:
                data_key, tweak_key = Crypto.pfs_gen_crypto_key(self.ekpfs_key, seed)

                if self.verbose:
                    print("Generated data and tweak keys for PFS decryption")

                # Decrypt the PFS image
                pfs_decrypted = Crypto.decrypt_pfs(data_key, tweak_key, pfs_encrypted)

                # Find the PFSC offset within the decrypted image
                pfsc_offset = self._get_pfsc_offset(pfs_decrypted)
                if pfsc_offset:
                    if self.verbose:
                        print(f"Found PFSC data at offset {hex(pfsc_offset)}")

                    # Extract the PFSC header and prepare for decompression
                    pfsc_data = pfs_decrypted[pfsc_offset:]

                    # Process the PFSC data (decompression and file extraction)
                    self._process_pfsc_data(pfsc_data)
                else:
                    print("Could not find PFSC data in the decrypted PFS image")
            else:
                print("EKPFS key not available, cannot decrypt PFS image")

                # For debugging, dump the encrypted image
                out_path = self.extract_path / "pfs_image.bin"
                with open(out_path, 'wb') as out:
                    out.write(pfs_encrypted)
                if self.verbose:
                    print(f"Encrypted PFS image written to {out_path} for debugging")

    def _get_pfsc_offset(self, pfs_data):
        """Find the offset of the PFSC data within the PFS image"""
        # Search for the PFSC magic number
        for i in range(0, len(pfs_data) - 4, 4):
            if struct.unpack("<I", pfs_data[i:i+4])[0] == PFS_COMPRESSION_MAGIC:
                return i
        return None

    def _decompress_pfsc_block(self, compressed_data):
        """Decompress a PFSC compressed block"""
        return zlib.decompress(compressed_data)

    def _process_pfsc_data(self, pfsc_data):
        """Process PFSC compressed data and extract files"""
        # Extract the PFSC header
        pfsc_header_size = 0x20
        if len(pfsc_data) < pfsc_header_size:
            print("PFSC data too small to contain header")
            return

        magic = struct.unpack("<I", pfsc_data[0:4])[0]
        if magic != PFS_COMPRESSION_MAGIC:
            print(f"Invalid PFSC magic: {hex(magic)}")
            return

        # Parse header fields
        block_size = struct.unpack("<I", pfsc_data[0xC:0x10])[0]
        data_offset = struct.unpack("<Q", pfsc_data[0x18:0x20])[0]

        if self.verbose:
            print(f"PFSC block size: {block_size}, data offset: {hex(data_offset)}")

        # Extract sector map entries
        sector_map_offset = pfsc_header_size
        sector_count = (data_offset - sector_map_offset) // 4

        sector_map = []
        for i in range(sector_count):
            offset = sector_map_offset + (i * 4)
            if offset + 4 <= len(pfsc_data):
                sector_map.append(struct.unpack("<I", pfsc_data[offset:offset+4])[0])

        if self.verbose:
            print(f"Read {len(sector_map)} sector map entries")

        # Decompress blocks and extract files
        decompressed_data = bytearray()

        for i in range(len(sector_map) - 1):
            sector_offset = sector_map[i]
            next_sector_offset = sector_map[i + 1]
            sector_size = next_sector_offset - sector_offset

            # Get the compressed block data
            block_start = data_offset + sector_offset
            block_end = data_offset + next_sector_offset

            if block_end <= len(pfsc_data):
                block_data = pfsc_data[block_start:block_end]

                # Check if the block is compressed (sector_size != block_size)
                if sector_size == block_size:
                    # Uncompressed block
                    decompressed_data.extend(block_data)
                else:
                    # Compressed block - decompress it
                    try:
                        decompressed_block = self._decompress_pfsc_block(block_data)
                        decompressed_data.extend(decompressed_block)
                    except Exception as e:
                        print(f"Failed to decompress block {i}: {str(e)}")
                        # Use the compressed data as a fallback
                        decompressed_data.extend(block_data)

        if self.verbose:
            print(f"Decompressed data size: {len(decompressed_data)}")

        # Now process the PFS file system from the decompressed data
        self._process_pfs_filesystem(decompressed_data)

    def _process_pfs_filesystem(self, pfs_data):
        """Process the PFS file system and extract files"""
        # Check PFS magic number
        if len(pfs_data) < 0x10 or struct.unpack("<I", pfs_data[8:12])[0] != PFS_MAGIC:
            print("Invalid PFS magic number in decompressed data")
            return

        # For debug purposes, save the decompressed PFS data
        if self.verbose:
            out_path = self.extract_path / "pfs_decompressed.bin"
            with open(out_path, 'wb') as out:
                out.write(pfs_data)
            print(f"Decompressed PFS filesystem written to {out_path} for debugging")

        # Parse PFS header
        # PfsHeader (simplified from src/core/file_format/pfs.h)
        header_size = 0x30  # Size of PSFHeader_ struct
        version = struct.unpack("<Q", pfs_data[0:8])[0]
        magic = struct.unpack("<Q", pfs_data[8:16])[0]
        pfs_id = struct.unpack("<Q", pfs_data[16:24])[0]

        # Skip other header fields - in a complete implementation we'd parse these
        block_size = struct.unpack("<I", pfs_data[0x28:0x2C])[0]
        n_blocks = struct.unpack("<Q", pfs_data[0x38:0x40])[0]
        dinode_count = struct.unpack("<Q", pfs_data[0x40:0x48])[0]
        nd_blocks = struct.unpack("<Q", pfs_data[0x48:0x50])[0]
        dinode_block_count = struct.unpack("<Q", pfs_data[0x50:0x58])[0]
        superroot_ino = struct.unpack("<Q", pfs_data[0x58:0x60])[0]

        if self.verbose:
            print(f"PFS Version: {version}")
            print(f"PFS Magic: {hex(magic)}")
            print(f"PFS ID: {pfs_id}")
            print(f"Block Size: {block_size}")
            print(f"Number of Blocks: {n_blocks}")
            print(f"Dinode Count: {dinode_count}")
            print(f"Superroot inode: {superroot_ino}")

        # Find and parse the superroot directory
        # In the PFS structure, the superroot points to the root directory
        # For simplicity, we'll start directly with the root directory by locating inodes

        # Calculate inode offset (after header)
        inode_offset = header_size

        # Parse inodes for files and directories
        self._extract_files_from_inodes(pfs_data, inode_offset, dinode_count, block_size)

    def _extract_files_from_inodes(self, pfs_data, inode_offset, dinode_count, block_size):
        """Extract files based on inodes in the PFS filesystem"""
        # Set up root directory for extraction
        root_dir = self.extract_path / "app"
        os.makedirs(root_dir, exist_ok=True)

        # Dictionary to track inodes (inode number -> file info)
        inode_map = {}

        # Dictionary to track directories (inode number -> directory path)
        dir_map = {}

        # Set up the root directory in our map
        dir_map[0] = root_dir  # Typically inode 0 is root, but PFS might use a different convention

        # Size of a PFS inode structure
        inode_size = 0x80

        # First pass: identify all inodes and their types (file/directory)
        for i in range(dinode_count):
            offset = inode_offset + (i * inode_size)
            if offset + inode_size > len(pfs_data):
                break

            # Parse the inode
            mode = struct.unpack("<H", pfs_data[offset:offset+2])[0]
            nlink = struct.unpack("<H", pfs_data[offset+2:offset+4])[0]
            uid = struct.unpack("<I", pfs_data[offset+4:offset+8])[0]
            gid = struct.unpack("<I", pfs_data[offset+8:offset+12])[0]
            size = struct.unpack("<Q", pfs_data[offset+12:offset+20])[0]

            # Get the data blocks (simplified - actual PFS has more complex allocation)
            block_ptrs = []
            for j in range(12):  # Direct blocks
                bptr_offset = offset + 0x20 + (j * 8)
                block_ptr = struct.unpack("<Q", pfs_data[bptr_offset:bptr_offset+8])[0]
                if block_ptr != 0:
                    block_ptrs.append(block_ptr)

            # Determine if it's a file or directory based on mode
            is_dir = (mode & 0x4000) == 0x4000
            is_file = (mode & 0x8000) == 0x8000

            if is_file or is_dir:
                inode_map[i] = {
                    'mode': mode,
                    'size': size,
                    'is_dir': is_dir,
                    'block_ptrs': block_ptrs
                }

                if self.verbose and (is_file or is_dir):
                    type_str = "Directory" if is_dir else "File"
                    print(f"Found {type_str} inode {i}, size: {size}, blocks: {len(block_ptrs)}")

        # Second pass: process directories to build the directory structure
        for inode_id, inode_info in inode_map.items():
            if not inode_info['is_dir']:
                continue

            # Process directory entries to build the hierarchy
            for block_ptr in inode_info['block_ptrs']:
                # Read directory entries from this block
                block_data_offset = block_ptr * block_size
                if block_data_offset + block_size > len(pfs_data):
                    continue

                # Parse the directory entries in this block
                entry_offset = block_data_offset
                while entry_offset < block_data_offset + block_size:
                    # Check if we have enough data for a directory entry
                    if entry_offset + 8 > len(pfs_data):
                        break

                    # Read the inode number and entry size
                    entry_inode = struct.unpack("<I", pfs_data[entry_offset:entry_offset+4])[0]
                    entry_size = struct.unpack("<H", pfs_data[entry_offset+4:entry_offset+6])[0]
                    name_len = struct.unpack("<H", pfs_data[entry_offset+6:entry_offset+8])[0]

                    if entry_size == 0:
                        # End of entries in this block
                        break

                    # Read the file/directory name
                    name_offset = entry_offset + 8
                    if name_offset + name_len <= len(pfs_data):
                        name = pfs_data[name_offset:name_offset+name_len].decode('utf-8', errors='replace')

                        # Skip "." and ".." entries
                        if name != "." and name != "..":
                            if inode_id in dir_map:
                                parent_dir = dir_map[inode_id]

                                # Create the full path for this entry
                                entry_path = parent_dir / name

                                # Record this path if it's a directory
                                if entry_inode in inode_map and inode_map[entry_inode]['is_dir']:
                                    os.makedirs(entry_path, exist_ok=True)
                                    dir_map[entry_inode] = entry_path

                                    if self.verbose:
                                        print(f"Created directory: {entry_path}")

                    # Move to the next directory entry
                    entry_offset += entry_size

        # Third pass: extract file contents
        files_extracted = 0
        for inode_id, inode_info in inode_map.items():
            if inode_info['is_dir']:
                continue  # Skip directories

            # Find the parent directory path for this file
            file_path = None
            for dir_inode_id, dir_inode_info in inode_map.items():
                if not dir_inode_info['is_dir']:
                    continue

                # Check if this file's inode is referenced in the directory
                for dir_block_ptr in dir_inode_info['block_ptrs']:
                    # Read directory entries from this block
                    block_data_offset = dir_block_ptr * block_size
                    if block_data_offset + block_size > len(pfs_data):
                        continue

                    entry_offset = block_data_offset
                    while entry_offset < block_data_offset + block_size:
                        # Check if we have enough data for a directory entry
                        if entry_offset + 8 > len(pfs_data):
                            break

                        # Read the inode number and entry size
                        entry_inode = struct.unpack("<I", pfs_data[entry_offset:entry_offset+4])[0]
                        entry_size = struct.unpack("<H", pfs_data[entry_offset+4:entry_offset+6])[0]
                        name_len = struct.unpack("<H", pfs_data[entry_offset+6:entry_offset+8])[0]

                        if entry_size == 0:
                            break

                        if entry_inode == inode_id:
                            # This directory entry points to our file
                            name_offset = entry_offset + 8
                            if name_offset + name_len <= len(pfs_data):
                                name = pfs_data[name_offset:name_offset+name_len].decode('utf-8', errors='replace')
                                if dir_inode_id in dir_map:
                                    file_path = dir_map[dir_inode_id] / name
                                    break

                        # Move to the next directory entry
                        entry_offset += entry_size

                    if file_path:
                        break

                if file_path:
                    break

            if file_path:
                # Extract the file content
                file_data = bytearray()
                size_remaining = inode_info['size']

                # Read content from data blocks
                for block_ptr in inode_info['block_ptrs']:
                    if size_remaining <= 0:
                        break

                    block_data_offset = block_ptr * block_size
                    if block_data_offset + block_size > len(pfs_data):
                        continue

                    # Read data from this block (up to remaining size)
                    bytes_to_read = min(block_size, size_remaining)
                    block_data = pfs_data[block_data_offset:block_data_offset+bytes_to_read]
                    file_data.extend(block_data)
                    size_remaining -= bytes_to_read

                # Save the file
                parent_dir = file_path.parent
                os.makedirs(parent_dir, exist_ok=True)
                with open(file_path, 'wb') as f:
                    f.write(file_data)

                files_extracted += 1
                if self.verbose:
                    print(f"Extracted file: {file_path} ({len(file_data)} bytes)")

        if self.verbose:
            print(f"Total files extracted: {files_extracted}")
        else:
            print(f"Extracted {files_extracted} files from PFS image")

    def decrypt_pkg(self, output_dir):
        self.extract_path = Path(output_dir)
        os.makedirs(self.extract_path, exist_ok=True)

        # Step 1: Extract and process crypto keys
        self.extract_all_entries()

        # Step 2: Extract the param.sfo and other metadata
        self._extract_param_sfo()

        # Step 3: Extract and decrypt the PFS image
        self.extract_pfs_image()

        print(f"Extraction complete to: {self.extract_path}")
        return True

    def _extract_param_sfo(self):
        """Extract the param.sfo file from the PKG entries"""
        sfo_entry = next((e for e in self.pkg_entries if e['id'] == 0x1000), None)
        if not sfo_entry:
            print("param.sfo not found in PKG entries!")
            return
        with open(self.pkg_path, 'rb') as f:
            f.seek(sfo_entry['offset'])
            sfo_data = f.read(sfo_entry['size'])
            self.sfo_data = sfo_data
            out_path = self.extract_path / "sce_sys" / "param.sfo"
            os.makedirs(out_path.parent, exist_ok=True)
            with open(out_path, 'wb') as out:
                out.write(sfo_data)
            if self.verbose:
                print(f"Extracted param.sfo to {out_path}")

def main():
    parser = argparse.ArgumentParser(description="Extract PS4 PKG files")
    parser.add_argument("pkg_path", nargs="?", help="Path to the PKG file")
    parser.add_argument("output_dir", nargs="?", help="Directory to extract files to")
    parser.add_argument("-v", "--verbose", action="store_true", help="Enable verbose output")
    args = parser.parse_args()

    # Check if required arguments are provided
    if not args.pkg_path or not args.output_dir:
        print("Error: Both pkg_path and output_dir arguments are required!")
        print("\nUsage:")
        print("  python ps4-pkg-extract.py /path/to/game.pkg /path/to/output/directory [-v]")
        print("\nExample:")
        print("  python ps4-pkg-extract.py PS4GAME.pkg ./extracted_game/")
        return 1

    extractor = PKGExtractor()
    extractor.verbose = args.verbose
    print(f"Opening PKG file: {args.pkg_path}")
    if not extractor.open(args.pkg_path):
        return 1
    print(f"Extracting to: {args.output_dir}")
    if not extractor.decrypt_pkg(args.output_dir):
        return 1
    return 0

if __name__ == "__main__":
    sys.exit(main())